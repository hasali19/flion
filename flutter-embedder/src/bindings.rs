/* automatically generated by rust-bindgen 0.71.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const FLUTTER_ENGINE_VERSION: u32 = 1;
pub type va_list = *mut ::std::os::raw::c_char;
unsafe extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
unsafe extern "C" {
    pub fn __security_init_cookie();
}
unsafe extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
unsafe extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
unsafe extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo();
}
unsafe extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
unsafe extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_data_public"]
        [::std::mem::size_of::<__crt_locale_data_public>() - 16usize];
    ["Alignment of __crt_locale_data_public"]
        [::std::mem::align_of::<__crt_locale_data_public>() - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_pctype"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_pctype) - 0usize];
    ["Offset of field: __crt_locale_data_public::_locale_mb_cur_max"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_mb_cur_max) - 8usize];
    ["Offset of field: __crt_locale_data_public::_locale_lc_codepage"]
        [::std::mem::offset_of!(__crt_locale_data_public, _locale_lc_codepage) - 12usize];
};
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __crt_locale_pointers"][::std::mem::size_of::<__crt_locale_pointers>() - 16usize];
    ["Alignment of __crt_locale_pointers"]
        [::std::mem::align_of::<__crt_locale_pointers>() - 8usize];
    ["Offset of field: __crt_locale_pointers::locinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, locinfo) - 0usize];
    ["Offset of field: __crt_locale_pointers::mbcinfo"]
        [::std::mem::offset_of!(__crt_locale_pointers, mbcinfo) - 8usize];
};
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _Mbstatet"][::std::mem::size_of::<_Mbstatet>() - 8usize];
    ["Alignment of _Mbstatet"][::std::mem::align_of::<_Mbstatet>() - 4usize];
    ["Offset of field: _Mbstatet::_Wchar"][::std::mem::offset_of!(_Mbstatet, _Wchar) - 0usize];
    ["Offset of field: _Mbstatet::_Byte"][::std::mem::offset_of!(_Mbstatet, _Byte) - 4usize];
    ["Offset of field: _Mbstatet::_State"][::std::mem::offset_of!(_Mbstatet, _State) - 6usize];
};
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
unsafe extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
unsafe extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn __threadhandle() -> usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const FlutterEngineResult_kSuccess: FlutterEngineResult = 0;
pub const FlutterEngineResult_kInvalidLibraryVersion: FlutterEngineResult = 1;
pub const FlutterEngineResult_kInvalidArguments: FlutterEngineResult = 2;
pub const FlutterEngineResult_kInternalInconsistency: FlutterEngineResult = 3;
pub type FlutterEngineResult = ::std::os::raw::c_int;
pub const FlutterRendererType_kOpenGL: FlutterRendererType = 0;
pub const FlutterRendererType_kSoftware: FlutterRendererType = 1;
#[doc = " Metal is only supported on Darwin platforms (macOS / iOS).\n iOS version >= 10.0 (device), 13.0 (simulator)\n macOS version >= 10.14"]
pub const FlutterRendererType_kMetal: FlutterRendererType = 2;
#[doc = " Metal is only supported on Darwin platforms (macOS / iOS).\n iOS version >= 10.0 (device), 13.0 (simulator)\n macOS version >= 10.14"]
pub const FlutterRendererType_kVulkan: FlutterRendererType = 3;
pub type FlutterRendererType = ::std::os::raw::c_int;
#[doc = " Indicate there is a running accessibility service which is changing the\n interaction model of the device."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureAccessibleNavigation:
    FlutterAccessibilityFeature = 1;
#[doc = " Indicate the platform is inverting the colors of the application."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureInvertColors:
    FlutterAccessibilityFeature = 2;
#[doc = " Request that animations be disabled or simplified."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureDisableAnimations:
    FlutterAccessibilityFeature = 4;
#[doc = " Request that text be rendered at a bold font weight."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureBoldText:
    FlutterAccessibilityFeature = 8;
#[doc = " Request that certain animations be simplified and parallax effects\n removed."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureReduceMotion:
    FlutterAccessibilityFeature = 16;
#[doc = " Request that UI be rendered with darker colors."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureHighContrast:
    FlutterAccessibilityFeature = 32;
#[doc = " Request to show on/off labels inside switches."]
pub const FlutterAccessibilityFeature_kFlutterAccessibilityFeatureOnOffSwitchLabels:
    FlutterAccessibilityFeature = 64;
#[doc = " Additional accessibility features that may be enabled by the platform.\n Must match the `AccessibilityFeatures` enum in window.dart."]
pub type FlutterAccessibilityFeature = ::std::os::raw::c_int;
#[doc = " The equivalent of a user briefly tapping the screen with the finger\n without moving it."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionTap: FlutterSemanticsAction = 1;
#[doc = " The equivalent of a user pressing and holding the screen with the finger\n for a few seconds without moving it."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionLongPress: FlutterSemanticsAction = 2;
#[doc = " The equivalent of a user moving their finger across the screen from right\n to left."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollLeft: FlutterSemanticsAction = 4;
#[doc = " The equivalent of a user moving their finger across the screen from left\n to\n right."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollRight: FlutterSemanticsAction = 8;
#[doc = " The equivalent of a user moving their finger across the screen from bottom\n to top."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollUp: FlutterSemanticsAction = 16;
#[doc = " The equivalent of a user moving their finger across the screen from top to\n bottom."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollDown: FlutterSemanticsAction = 32;
#[doc = " Increase the value represented by the semantics node."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionIncrease: FlutterSemanticsAction = 64;
#[doc = " Decrease the value represented by the semantics node."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDecrease: FlutterSemanticsAction = 128;
#[doc = " A request to fully show the semantics node on screen."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionShowOnScreen: FlutterSemanticsAction = 256;
#[doc = " Move the cursor forward by one character."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorForwardByCharacter:
    FlutterSemanticsAction = 512;
#[doc = " Move the cursor backward by one character."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorBackwardByCharacter:
    FlutterSemanticsAction = 1024;
#[doc = " Set the text selection to the given range."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionSetSelection: FlutterSemanticsAction = 2048;
#[doc = " Copy the current selection to the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCopy: FlutterSemanticsAction = 4096;
#[doc = " Cut the current selection and place it in the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCut: FlutterSemanticsAction = 8192;
#[doc = " Paste the current content of the clipboard."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionPaste: FlutterSemanticsAction = 16384;
#[doc = " Indicate that the node has gained accessibility focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDidGainAccessibilityFocus:
    FlutterSemanticsAction = 32768;
#[doc = " Indicate that the node has lost accessibility focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDidLoseAccessibilityFocus:
    FlutterSemanticsAction = 65536;
#[doc = " Indicate that the user has invoked a custom accessibility action."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionCustomAction: FlutterSemanticsAction =
    131072;
#[doc = " A request that the node should be dismissed."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionDismiss: FlutterSemanticsAction = 262144;
#[doc = " Move the cursor forward by one word."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorForwardByWord:
    FlutterSemanticsAction = 524288;
#[doc = " Move the cursor backward by one word."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionMoveCursorBackwardByWord:
    FlutterSemanticsAction = 1048576;
#[doc = " Replace the current text in the text field."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionSetText: FlutterSemanticsAction = 2097152;
#[doc = " Request that the respective focusable widget gain input focus."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionFocus: FlutterSemanticsAction = 4194304;
#[doc = " Request that scrolls the current scrollable container to a given scroll\n offset."]
pub const FlutterSemanticsAction_kFlutterSemanticsActionScrollToOffset: FlutterSemanticsAction =
    8388608;
#[doc = " The set of possible actions that can be conveyed to a semantics node.\n\n Must match the `SemanticsAction` enum in semantics.dart."]
pub type FlutterSemanticsAction = ::std::os::raw::c_int;
#[doc = " The semantics node has the quality of either being \"checked\" or\n \"unchecked\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasCheckedState: FlutterSemanticsFlag = 1;
#[doc = " Whether a semantics node is checked."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsChecked: FlutterSemanticsFlag = 2;
#[doc = " Whether a semantics node is selected."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsSelected: FlutterSemanticsFlag = 4;
#[doc = " Whether the semantic node represents a button."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsButton: FlutterSemanticsFlag = 8;
#[doc = " Whether the semantic node represents a text field."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsTextField: FlutterSemanticsFlag = 16;
#[doc = " Whether the semantic node currently holds the user's focus."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsFocused: FlutterSemanticsFlag = 32;
#[doc = " The semantics node has the quality of either being \"enabled\" or\n \"disabled\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasEnabledState: FlutterSemanticsFlag = 64;
#[doc = " Whether a semantic node that hasEnabledState is currently enabled."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsEnabled: FlutterSemanticsFlag = 128;
#[doc = " Whether a semantic node is in a mutually exclusive group."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsInMutuallyExclusiveGroup:
    FlutterSemanticsFlag = 256;
#[doc = " Whether a semantic node is a header that divides content into sections."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsHeader: FlutterSemanticsFlag = 512;
#[doc = " Whether the value of the semantics node is obscured."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsObscured: FlutterSemanticsFlag = 1024;
#[doc = " Whether the semantics node is the root of a subtree for which a route name\n should be announced."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagScopesRoute: FlutterSemanticsFlag = 2048;
#[doc = " Whether the semantics node label is the name of a visually distinct route."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagNamesRoute: FlutterSemanticsFlag = 4096;
#[doc = " Whether the semantics node is considered hidden."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsHidden: FlutterSemanticsFlag = 8192;
#[doc = " Whether the semantics node represents an image."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsImage: FlutterSemanticsFlag = 16384;
#[doc = " Whether the semantics node is a live region."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsLiveRegion: FlutterSemanticsFlag = 32768;
#[doc = " The semantics node has the quality of either being \"on\" or \"off\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasToggledState: FlutterSemanticsFlag = 65536;
#[doc = " If true, the semantics node is \"on\". If false, the semantics node is\n \"off\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsToggled: FlutterSemanticsFlag = 131072;
#[doc = " Whether the platform can scroll the semantics node when the user attempts\n to move the accessibility focus to an offscreen child.\n\n For example, a `ListView` widget has implicit scrolling so that users can\n easily move the accessibility focus to the next set of children. A\n `PageView` widget does not have implicit scrolling, so that users don't\n navigate to the next page when reaching the end of the current one."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasImplicitScrolling: FlutterSemanticsFlag =
    262144;
#[doc = " Whether the value of the semantics node is coming from a multi-line text\n field.\n\n This is used for text fields to distinguish single-line text fields from\n multi-line ones."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsMultiline: FlutterSemanticsFlag = 524288;
#[doc = " Whether the semantic node is read only.\n\n Only applicable when kFlutterSemanticsFlagIsTextField flag is on."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsReadOnly: FlutterSemanticsFlag = 1048576;
#[doc = " Whether the semantic node can hold the user's focus."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsFocusable: FlutterSemanticsFlag = 2097152;
#[doc = " Whether the semantics node represents a link."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsLink: FlutterSemanticsFlag = 4194304;
#[doc = " Whether the semantics node represents a slider."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsSlider: FlutterSemanticsFlag = 8388608;
#[doc = " Whether the semantics node represents a keyboard key."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsKeyboardKey: FlutterSemanticsFlag = 16777216;
#[doc = " Whether the semantics node represents a tristate checkbox in mixed state."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsCheckStateMixed: FlutterSemanticsFlag =
    33554432;
#[doc = " The semantics node has the quality of either being \"expanded\" or\n \"collapsed\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasExpandedState: FlutterSemanticsFlag =
    67108864;
#[doc = " Whether a semantic node that hasExpandedState is currently expanded."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagIsExpanded: FlutterSemanticsFlag = 134217728;
#[doc = " The semantics node has the quality of either being \"selected\" or\n \"not selected\"."]
pub const FlutterSemanticsFlag_kFlutterSemanticsFlagHasSelectedState: FlutterSemanticsFlag =
    268435456;
#[doc = " The set of properties that may be associated with a semantics node.\n\n Must match the `SemanticsFlag` enum in semantics.dart."]
pub type FlutterSemanticsFlag = ::std::os::raw::c_int;
#[doc = " Text has unknown text direction."]
pub const FlutterTextDirection_kFlutterTextDirectionUnknown: FlutterTextDirection = 0;
#[doc = " Text is read from right to left."]
pub const FlutterTextDirection_kFlutterTextDirectionRTL: FlutterTextDirection = 1;
#[doc = " Text is read from left to right."]
pub const FlutterTextDirection_kFlutterTextDirectionLTR: FlutterTextDirection = 2;
pub type FlutterTextDirection = ::std::os::raw::c_int;
#[doc = " Suitable for threads that shouldn't disrupt high priority work."]
pub const FlutterThreadPriority_kBackground: FlutterThreadPriority = 0;
#[doc = " Default priority level."]
pub const FlutterThreadPriority_kNormal: FlutterThreadPriority = 1;
#[doc = " Suitable for threads which generate data for the display."]
pub const FlutterThreadPriority_kDisplay: FlutterThreadPriority = 2;
#[doc = " Suitable for thread which raster data."]
pub const FlutterThreadPriority_kRaster: FlutterThreadPriority = 3;
#[doc = " Valid values for priority of Thread."]
pub type FlutterThreadPriority = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterEngine {
    _unused: [u8; 0],
}
pub type FlutterEngine = *mut _FlutterEngine;
#[doc = " Unique identifier for views.\n\n View IDs are generated by the embedder and are\n opaque to the engine; the engine does not interpret view IDs in any way."]
pub type FlutterViewId = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterTransformation {
    #[doc = " horizontal scale factor"]
    pub scaleX: f64,
    #[doc = " horizontal skew factor"]
    pub skewX: f64,
    #[doc = " horizontal translation"]
    pub transX: f64,
    #[doc = " vertical skew factor"]
    pub skewY: f64,
    #[doc = " vertical scale factor"]
    pub scaleY: f64,
    #[doc = " vertical translation"]
    pub transY: f64,
    #[doc = " input x-axis perspective factor"]
    pub pers0: f64,
    #[doc = " input y-axis perspective factor"]
    pub pers1: f64,
    #[doc = " perspective scale factor"]
    pub pers2: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTransformation"][::std::mem::size_of::<FlutterTransformation>() - 72usize];
    ["Alignment of FlutterTransformation"]
        [::std::mem::align_of::<FlutterTransformation>() - 8usize];
    ["Offset of field: FlutterTransformation::scaleX"]
        [::std::mem::offset_of!(FlutterTransformation, scaleX) - 0usize];
    ["Offset of field: FlutterTransformation::skewX"]
        [::std::mem::offset_of!(FlutterTransformation, skewX) - 8usize];
    ["Offset of field: FlutterTransformation::transX"]
        [::std::mem::offset_of!(FlutterTransformation, transX) - 16usize];
    ["Offset of field: FlutterTransformation::skewY"]
        [::std::mem::offset_of!(FlutterTransformation, skewY) - 24usize];
    ["Offset of field: FlutterTransformation::scaleY"]
        [::std::mem::offset_of!(FlutterTransformation, scaleY) - 32usize];
    ["Offset of field: FlutterTransformation::transY"]
        [::std::mem::offset_of!(FlutterTransformation, transY) - 40usize];
    ["Offset of field: FlutterTransformation::pers0"]
        [::std::mem::offset_of!(FlutterTransformation, pers0) - 48usize];
    ["Offset of field: FlutterTransformation::pers1"]
        [::std::mem::offset_of!(FlutterTransformation, pers1) - 56usize];
    ["Offset of field: FlutterTransformation::pers2"]
        [::std::mem::offset_of!(FlutterTransformation, pers2) - 64usize];
};
pub type VoidCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " Specifies an OpenGL texture target type. Textures are specified using\n the FlutterOpenGLTexture struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeTexture: FlutterOpenGLTargetType = 0;
#[doc = " Specifies an OpenGL frame-buffer target type. Framebuffers are specified\n using the FlutterOpenGLFramebuffer struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeFramebuffer: FlutterOpenGLTargetType = 1;
#[doc = " Specifies an OpenGL on-screen surface target type. Surfaces are specified\n using the FlutterOpenGLSurface struct."]
pub const FlutterOpenGLTargetType_kFlutterOpenGLTargetTypeSurface: FlutterOpenGLTargetType = 2;
pub type FlutterOpenGLTargetType = ::std::os::raw::c_int;
#[doc = " Pixel with 8 bit grayscale value.\n The grayscale value is the luma value calculated from r, g, b\n according to BT.709. (gray = r*0.2126 + g*0.7152 + b*0.0722)"]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatGray8: FlutterSoftwarePixelFormat =
    0;
#[doc = " Pixel with 5 bits red, 6 bits green, 5 bits blue, in 16-bit word.\n   r = (p >> 11) & 0x1F;\n   g = (p >> 5) & 0x3F;\n   b = p & 0x1F;\n\n On most (== little-endian) systems, this is equivalent to wayland format\n RGB565 (WL_DRM_FORMAT_RGB565, WL_SHM_FORMAT_RGB565)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGB565: FlutterSoftwarePixelFormat =
    1;
#[doc = " Pixel with 4 bits each for alpha, red, green, blue; in 16-bit word.\n   r = (p >> 8) & 0xF;\n   g = (p >> 4) & 0xF;\n   b = p & 0xF;\n   a = (p >> 12) & 0xF;\n\n On most (== little-endian) systems, this is equivalent to wayland format\n RGBA4444 (WL_DRM_FORMAT_RGBA4444, WL_SHM_FORMAT_RGBA4444)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBA4444:
    FlutterSoftwarePixelFormat = 2;
#[doc = " Pixel with 8 bits each for red, green, blue, alpha.\n   r = p[0];\n   g = p[1];\n   b = p[2];\n   a = p[3];\n\n This is equivalent to wayland format ABGR8888 (WL_DRM_FORMAT_ABGR8888,\n WL_SHM_FORMAT_ABGR8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBA8888:
    FlutterSoftwarePixelFormat = 3;
#[doc = " Pixel with 8 bits each for red, green and blue and 8 unused bits.\n   r = p[0];\n   g = p[1];\n   b = p[2];\n\n This is equivalent to wayland format XBGR8888 (WL_DRM_FORMAT_XBGR8888,\n WL_SHM_FORMAT_XBGR8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatRGBX8888:
    FlutterSoftwarePixelFormat = 4;
#[doc = " Pixel with 8 bits each for blue, green, red and alpha.\n   r = p[2];\n   g = p[1];\n   b = p[0];\n   a = p[3];\n\n This is equivalent to wayland format ARGB8888 (WL_DRM_FORMAT_ARGB8888,\n WL_SHM_FORMAT_ARGB8888)."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatBGRA8888:
    FlutterSoftwarePixelFormat = 5;
#[doc = " Either kFlutterSoftwarePixelFormatBGRA8888 or\n kFlutterSoftwarePixelFormatRGBA8888 depending on CPU endianess and OS."]
pub const FlutterSoftwarePixelFormat_kFlutterSoftwarePixelFormatNative32:
    FlutterSoftwarePixelFormat = 6;
#[doc = " A pixel format to be used for software rendering.\n\n A single pixel always stored as a POT number of bytes. (so in practice\n either 1, 2, 4, 8, 16 bytes per pixel)\n\n There are two kinds of pixel formats:\n   - formats where all components are 8 bits, called array formats\n     The component order as specified in the pixel format name is the\n     order of the components' bytes in memory, with the leftmost component\n     occupying the lowest memory address.\n\n   - all other formats are called packed formats, and the component order\n     as specified in the format name refers to the order from most\n     significant to least significant bits in the native type. for example,\n     for kFlutterSoftwarePixelFormatRGB565, R occupies the 5 most significant\n     bits, G the middle 6 bits, and B the 5 least significant bits.\n\n Each pixel format in this list is documented with an example on how to get\n the color components from the pixel.\n - for packed formats, p is the pixel value as a word. For example, you can\n   get the pixel value for a RGB565 formatted buffer like this:\n   uint16_t p = ((const uint16_t*) allocation)[row_bytes * y / bpp + x];\n   (with bpp being the bytes per pixel, so 2 for RGB565)\n\n - for array formats, p is a pointer to the pixel value. For example, you\n   can get the p for a RGBA8888 formatted buffer like this:\n   const uint8_t *p = ((const uint8_t*) allocation) + row_bytes*y + x*4;"]
pub type FlutterSoftwarePixelFormat = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLTexture {
    #[doc = " Target texture of the active texture unit (example GL_TEXTURE_2D or\n GL_TEXTURE_RECTANGLE)."]
    pub target: u32,
    #[doc = " The name of the texture."]
    pub name: u32,
    #[doc = " The texture format (example GL_RGBA8)."]
    pub format: u32,
    #[doc = " User data to be returned on the invocation of the destruction callback."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine managed thread) that asks the embedder to\n collect the texture."]
    pub destruction_callback: VoidCallback,
    #[doc = " Optional parameters for texture height/width, default is 0, non-zero means\n the texture has the specified width/height. Usually, when the texture type\n is GL_TEXTURE_RECTANGLE, we need to specify the texture width/height to\n tell the embedder to scale when rendering.\n Width of the texture."]
    pub width: usize,
    #[doc = " Height of the texture."]
    pub height: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLTexture"][::std::mem::size_of::<FlutterOpenGLTexture>() - 48usize];
    ["Alignment of FlutterOpenGLTexture"][::std::mem::align_of::<FlutterOpenGLTexture>() - 8usize];
    ["Offset of field: FlutterOpenGLTexture::target"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, target) - 0usize];
    ["Offset of field: FlutterOpenGLTexture::name"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, name) - 4usize];
    ["Offset of field: FlutterOpenGLTexture::format"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, format) - 8usize];
    ["Offset of field: FlutterOpenGLTexture::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, user_data) - 16usize];
    ["Offset of field: FlutterOpenGLTexture::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, destruction_callback) - 24usize];
    ["Offset of field: FlutterOpenGLTexture::width"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, width) - 32usize];
    ["Offset of field: FlutterOpenGLTexture::height"]
        [::std::mem::offset_of!(FlutterOpenGLTexture, height) - 40usize];
};
impl Default for FlutterOpenGLTexture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLFramebuffer {
    #[doc = " The format of the color attachment of the frame-buffer. For example,\n GL_RGBA8.\n\n In case of ambiguity when dealing with Window bound frame-buffers, 0 may\n be used.\n\n @bug      This field is incorrectly named as \"target\" when it actually\n           refers to a format."]
    pub target: u32,
    #[doc = " The name of the framebuffer."]
    pub name: u32,
    #[doc = " User data to be returned on the invocation of the destruction callback."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine managed thread) that asks the embedder to\n collect the framebuffer."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLFramebuffer"]
        [::std::mem::size_of::<FlutterOpenGLFramebuffer>() - 24usize];
    ["Alignment of FlutterOpenGLFramebuffer"]
        [::std::mem::align_of::<FlutterOpenGLFramebuffer>() - 8usize];
    ["Offset of field: FlutterOpenGLFramebuffer::target"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, target) - 0usize];
    ["Offset of field: FlutterOpenGLFramebuffer::name"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, name) - 4usize];
    ["Offset of field: FlutterOpenGLFramebuffer::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, user_data) - 8usize];
    ["Offset of field: FlutterOpenGLFramebuffer::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLFramebuffer, destruction_callback) - 16usize];
};
impl Default for FlutterOpenGLFramebuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterOpenGLSurfaceCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut bool) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterOpenGLSurface {
    #[doc = " The size of this struct. Must be sizeof(FlutterOpenGLSurface)."]
    pub struct_size: usize,
    #[doc = " User data to be passed to the make_current, clear_current and\n destruction callbacks."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Callback invoked (on an engine-managed thread) that asks the embedder to\n make the surface current.\n\n Should return true if the operation succeeded, false if the surface could\n not be made current and rendering should be cancelled.\n\n The second parameter 'opengl state changed' should be set to true if\n any OpenGL API state is different than before this callback was called.\n In that case, Flutter will invalidate the internal OpenGL API state cache,\n which is a somewhat expensive operation.\n\n @attention required. (non-null)"]
    pub make_current_callback: FlutterOpenGLSurfaceCallback,
    #[doc = " Callback invoked (on an engine-managed thread) when the current surface\n can be cleared.\n\n Should return true if the operation succeeded, false if an error ocurred.\n That error will be logged but otherwise not handled by the engine.\n\n The second parameter 'opengl state changed' is the same as with the\n @ref make_current_callback.\n\n The embedder might clear the surface here after it was previously made\n current. That's not required however, it's also possible to clear it in\n the destruction callback. There's no way to signal OpenGL state\n changes in the destruction callback though.\n\n @attention required. (non-null)"]
    pub clear_current_callback: FlutterOpenGLSurfaceCallback,
    #[doc = " Callback invoked (on an engine-managed thread) that asks the embedder to\n collect the surface.\n\n @attention required. (non-null)"]
    pub destruction_callback: VoidCallback,
    #[doc = " The surface format.\n\n Allowed values:\n   - GL_RGBA8\n   - GL_BGRA8_EXT"]
    pub format: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLSurface"][::std::mem::size_of::<FlutterOpenGLSurface>() - 48usize];
    ["Alignment of FlutterOpenGLSurface"][::std::mem::align_of::<FlutterOpenGLSurface>() - 8usize];
    ["Offset of field: FlutterOpenGLSurface::struct_size"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, struct_size) - 0usize];
    ["Offset of field: FlutterOpenGLSurface::user_data"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, user_data) - 8usize];
    ["Offset of field: FlutterOpenGLSurface::make_current_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, make_current_callback) - 16usize];
    ["Offset of field: FlutterOpenGLSurface::clear_current_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, clear_current_callback) - 24usize];
    ["Offset of field: FlutterOpenGLSurface::destruction_callback"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, destruction_callback) - 32usize];
    ["Offset of field: FlutterOpenGLSurface::format"]
        [::std::mem::offset_of!(FlutterOpenGLSurface, format) - 40usize];
};
impl Default for FlutterOpenGLSurface {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type BoolCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> bool>;
pub type TransformationCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> FlutterTransformation,
>;
pub type UIntCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> u32>;
pub type SoftwareSurfacePresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
    ) -> bool,
>;
pub type ProcResolver = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type TextureFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: i64,
        arg3: usize,
        arg4: usize,
        arg5: *mut FlutterOpenGLTexture,
    ) -> bool,
>;
pub type VsyncCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: isize)>;
pub type OnPreEngineRestartCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[doc = " A structure to represent the width and height."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterSize {
    pub width: f64,
    pub height: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSize"][::std::mem::size_of::<FlutterSize>() - 16usize];
    ["Alignment of FlutterSize"][::std::mem::align_of::<FlutterSize>() - 8usize];
    ["Offset of field: FlutterSize::width"][::std::mem::offset_of!(FlutterSize, width) - 0usize];
    ["Offset of field: FlutterSize::height"][::std::mem::offset_of!(FlutterSize, height) - 8usize];
};
#[doc = " A structure to represent the width and height.\n\n See: \\ref FlutterSize when the value are not integers."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterUIntSize {
    pub width: u32,
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterUIntSize"][::std::mem::size_of::<FlutterUIntSize>() - 8usize];
    ["Alignment of FlutterUIntSize"][::std::mem::align_of::<FlutterUIntSize>() - 4usize];
    ["Offset of field: FlutterUIntSize::width"]
        [::std::mem::offset_of!(FlutterUIntSize, width) - 0usize];
    ["Offset of field: FlutterUIntSize::height"]
        [::std::mem::offset_of!(FlutterUIntSize, height) - 4usize];
};
#[doc = " A structure to represent a rectangle."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterRect {
    pub left: f64,
    pub top: f64,
    pub right: f64,
    pub bottom: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRect"][::std::mem::size_of::<FlutterRect>() - 32usize];
    ["Alignment of FlutterRect"][::std::mem::align_of::<FlutterRect>() - 8usize];
    ["Offset of field: FlutterRect::left"][::std::mem::offset_of!(FlutterRect, left) - 0usize];
    ["Offset of field: FlutterRect::top"][::std::mem::offset_of!(FlutterRect, top) - 8usize];
    ["Offset of field: FlutterRect::right"][::std::mem::offset_of!(FlutterRect, right) - 16usize];
    ["Offset of field: FlutterRect::bottom"][::std::mem::offset_of!(FlutterRect, bottom) - 24usize];
};
#[doc = " A structure to represent a 2D point."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterPoint {
    pub x: f64,
    pub y: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPoint"][::std::mem::size_of::<FlutterPoint>() - 16usize];
    ["Alignment of FlutterPoint"][::std::mem::align_of::<FlutterPoint>() - 8usize];
    ["Offset of field: FlutterPoint::x"][::std::mem::offset_of!(FlutterPoint, x) - 0usize];
    ["Offset of field: FlutterPoint::y"][::std::mem::offset_of!(FlutterPoint, y) - 8usize];
};
#[doc = " A structure to represent a rounded rectangle."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterRoundedRect {
    pub rect: FlutterRect,
    pub upper_left_corner_radius: FlutterSize,
    pub upper_right_corner_radius: FlutterSize,
    pub lower_right_corner_radius: FlutterSize,
    pub lower_left_corner_radius: FlutterSize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRoundedRect"][::std::mem::size_of::<FlutterRoundedRect>() - 96usize];
    ["Alignment of FlutterRoundedRect"][::std::mem::align_of::<FlutterRoundedRect>() - 8usize];
    ["Offset of field: FlutterRoundedRect::rect"]
        [::std::mem::offset_of!(FlutterRoundedRect, rect) - 0usize];
    ["Offset of field: FlutterRoundedRect::upper_left_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, upper_left_corner_radius) - 32usize];
    ["Offset of field: FlutterRoundedRect::upper_right_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, upper_right_corner_radius) - 48usize];
    ["Offset of field: FlutterRoundedRect::lower_right_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, lower_right_corner_radius) - 64usize];
    ["Offset of field: FlutterRoundedRect::lower_left_corner_radius"]
        [::std::mem::offset_of!(FlutterRoundedRect, lower_left_corner_radius) - 80usize];
};
#[doc = " A structure to represent a damage region."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterDamage {
    #[doc = " The size of this struct. Must be sizeof(FlutterDamage)."]
    pub struct_size: usize,
    #[doc = " The number of rectangles within the damage region."]
    pub num_rects: usize,
    #[doc = " The actual damage region(s) in question."]
    pub damage: *mut FlutterRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterDamage"][::std::mem::size_of::<FlutterDamage>() - 24usize];
    ["Alignment of FlutterDamage"][::std::mem::align_of::<FlutterDamage>() - 8usize];
    ["Offset of field: FlutterDamage::struct_size"]
        [::std::mem::offset_of!(FlutterDamage, struct_size) - 0usize];
    ["Offset of field: FlutterDamage::num_rects"]
        [::std::mem::offset_of!(FlutterDamage, num_rects) - 8usize];
    ["Offset of field: FlutterDamage::damage"]
        [::std::mem::offset_of!(FlutterDamage, damage) - 16usize];
};
impl Default for FlutterDamage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This information is passed to the embedder when requesting a frame buffer\n object.\n\n See: \\ref FlutterOpenGLRendererConfig.fbo_with_frame_info_callback,\n \\ref FlutterMetalRendererConfig.get_next_drawable_callback,\n and \\ref FlutterVulkanRendererConfig.get_next_image_callback."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterFrameInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterFrameInfo)."]
    pub struct_size: usize,
    #[doc = " The size of the surface that will be backed by the fbo."]
    pub size: FlutterUIntSize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterFrameInfo"][::std::mem::size_of::<FlutterFrameInfo>() - 16usize];
    ["Alignment of FlutterFrameInfo"][::std::mem::align_of::<FlutterFrameInfo>() - 8usize];
    ["Offset of field: FlutterFrameInfo::struct_size"]
        [::std::mem::offset_of!(FlutterFrameInfo, struct_size) - 0usize];
    ["Offset of field: FlutterFrameInfo::size"]
        [::std::mem::offset_of!(FlutterFrameInfo, size) - 8usize];
};
#[doc = " Callback for when a frame buffer object is requested."]
pub type UIntFrameInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *const FlutterFrameInfo) -> u32,
>;
#[doc = " Callback for when a frame buffer object is requested with necessary\n information for partial repaint."]
pub type FlutterFrameBufferWithDamageCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: isize, arg3: *mut FlutterDamage),
>;
#[doc = " This information is passed to the embedder when a surface is presented.\n\n See: \\ref FlutterOpenGLRendererConfig.present_with_info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPresentInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterPresentInfo)."]
    pub struct_size: usize,
    #[doc = " Id of the fbo backing the surface that was presented."]
    pub fbo_id: u32,
    #[doc = " Damage representing the area that the compositor needs to render."]
    pub frame_damage: FlutterDamage,
    #[doc = " Damage used to set the buffer's damage region."]
    pub buffer_damage: FlutterDamage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPresentInfo"][::std::mem::size_of::<FlutterPresentInfo>() - 64usize];
    ["Alignment of FlutterPresentInfo"][::std::mem::align_of::<FlutterPresentInfo>() - 8usize];
    ["Offset of field: FlutterPresentInfo::struct_size"]
        [::std::mem::offset_of!(FlutterPresentInfo, struct_size) - 0usize];
    ["Offset of field: FlutterPresentInfo::fbo_id"]
        [::std::mem::offset_of!(FlutterPresentInfo, fbo_id) - 8usize];
    ["Offset of field: FlutterPresentInfo::frame_damage"]
        [::std::mem::offset_of!(FlutterPresentInfo, frame_damage) - 16usize];
    ["Offset of field: FlutterPresentInfo::buffer_damage"]
        [::std::mem::offset_of!(FlutterPresentInfo, buffer_damage) - 40usize];
};
impl Default for FlutterPresentInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback for when a surface is presented."]
pub type BoolPresentInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterPresentInfo,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterOpenGLRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterOpenGLRendererConfig)."]
    pub struct_size: usize,
    pub make_current: BoolCallback,
    pub clear_current: BoolCallback,
    #[doc = " Specifying one (and only one) of `present` or `present_with_info` is\n required. Specifying both is an error and engine initialization will be\n terminated. The return value indicates success of the present call. If\n the intent is to use dirty region management, present_with_info must be\n defined as present will not succeed in communicating information about\n damage."]
    pub present: BoolCallback,
    #[doc = " Specifying one (and only one) of the `fbo_callback` or\n `fbo_with_frame_info_callback` is required. Specifying both is an error\n and engine intialization will be terminated. The return value indicates\n the id of the frame buffer object that flutter will obtain the gl surface\n from."]
    pub fbo_callback: UIntCallback,
    #[doc = " This is an optional callback. Flutter will ask the emebdder to create a GL\n context current on a background thread. If the embedder is able to do so,\n Flutter will assume that this context is in the same sharegroup as the\n main rendering context and use this context for asynchronous texture\n uploads. Though optional, it is recommended that all embedders set this\n callback as it will lead to better performance in texture handling."]
    pub make_resource_current: BoolCallback,
    #[doc = " By default, the renderer config assumes that the FBO does not change for\n the duration of the engine run. If this argument is true, the\n engine will ask the embedder for an updated FBO target (via an\n fbo_callback invocation) after a present call."]
    pub fbo_reset_after_present: bool,
    #[doc = " The transformation to apply to the render target before any rendering\n operations. This callback is optional.\n @attention      When using a custom compositor, the layer offset and sizes\n                 will be affected by this transformation. It will be\n                 embedder responsibility to render contents at the\n                 transformed offset and size. This is useful for embedders\n                 that want to render transformed contents directly into\n                 hardware overlay planes without having to apply extra\n                 transformations to layer contents (which may necessitate\n                 an expensive off-screen render pass)."]
    pub surface_transformation: TransformationCallback,
    pub gl_proc_resolver: ProcResolver,
    #[doc = " When the embedder specifies that a texture has a frame available, the\n engine will call this method (on an internal engine managed thread) so\n that external texture details can be supplied to the engine for subsequent\n composition."]
    pub gl_external_texture_frame_callback: TextureFrameCallback,
    #[doc = " Specifying one (and only one) of the `fbo_callback` or\n `fbo_with_frame_info_callback` is required. Specifying both is an error\n and engine intialization will be terminated. The return value indicates\n the id of the frame buffer object (fbo) that flutter will obtain the gl\n surface from. When using this variant, the embedder is passed a\n `FlutterFrameInfo` struct that indicates the properties of the surface\n that flutter will acquire from the returned fbo."]
    pub fbo_with_frame_info_callback: UIntFrameInfoCallback,
    #[doc = " Specifying one (and only one) of `present` or `present_with_info` is\n required. Specifying both is an error and engine initialization will be\n terminated. When using this variant, the embedder is passed a\n `FlutterPresentInfo` struct that the embedder can use to release any\n resources. The return value indicates success of the present call. This\n callback is essential for dirty region management. If not defined, all the\n pixels on the screen will be rendered at every frame (regardless of\n whether damage is actually being computed or not). This is because the\n information that is passed along to the callback contains the frame and\n buffer damage that are essential for dirty region management."]
    pub present_with_info: BoolPresentInfoCallback,
    #[doc = " Specifying this callback is a requirement for dirty region management.\n Dirty region management will only render the areas of the screen that have\n changed in between frames, greatly reducing rendering times and energy\n consumption. To take advantage of these benefits, it is necessary to\n define populate_existing_damage as a callback that takes user\n data, an FBO ID, and an existing damage FlutterDamage. The callback should\n use the given FBO ID to identify the FBO's exisiting damage (i.e. areas\n that have changed since the FBO was last used) and use it to populate the\n given existing damage variable. This callback is dependent on either\n fbo_callback or fbo_with_frame_info_callback being defined as they are\n responsible for providing populate_existing_damage with the FBO's\n ID. Not specifying populate_existing_damage will result in full\n repaint (i.e. rendering all the pixels on the screen at every frame)."]
    pub populate_existing_damage: FlutterFrameBufferWithDamageCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLRendererConfig"]
        [::std::mem::size_of::<FlutterOpenGLRendererConfig>() - 104usize];
    ["Alignment of FlutterOpenGLRendererConfig"]
        [::std::mem::align_of::<FlutterOpenGLRendererConfig>() - 8usize];
    ["Offset of field: FlutterOpenGLRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterOpenGLRendererConfig::make_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, make_current) - 8usize];
    ["Offset of field: FlutterOpenGLRendererConfig::clear_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, clear_current) - 16usize];
    ["Offset of field: FlutterOpenGLRendererConfig::present"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, present) - 24usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_callback"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, fbo_callback) - 32usize];
    ["Offset of field: FlutterOpenGLRendererConfig::make_resource_current"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, make_resource_current) - 40usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_reset_after_present"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, fbo_reset_after_present) - 48usize];
    ["Offset of field: FlutterOpenGLRendererConfig::surface_transformation"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, surface_transformation) - 56usize];
    ["Offset of field: FlutterOpenGLRendererConfig::gl_proc_resolver"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, gl_proc_resolver) - 64usize];
    ["Offset of field: FlutterOpenGLRendererConfig::gl_external_texture_frame_callback"][::std::mem::offset_of!(
        FlutterOpenGLRendererConfig,
        gl_external_texture_frame_callback
    )
        - 72usize];
    ["Offset of field: FlutterOpenGLRendererConfig::fbo_with_frame_info_callback"][::std::mem::offset_of!(
        FlutterOpenGLRendererConfig,
        fbo_with_frame_info_callback
    ) - 80usize];
    ["Offset of field: FlutterOpenGLRendererConfig::present_with_info"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, present_with_info) - 88usize];
    ["Offset of field: FlutterOpenGLRendererConfig::populate_existing_damage"]
        [::std::mem::offset_of!(FlutterOpenGLRendererConfig, populate_existing_damage) - 96usize];
};
#[doc = " Alias for id<MTLDevice>."]
pub type FlutterMetalDeviceHandle = *const ::std::os::raw::c_void;
#[doc = " Alias for id<MTLCommandQueue>."]
pub type FlutterMetalCommandQueueHandle = *const ::std::os::raw::c_void;
#[doc = " Alias for id<MTLTexture>."]
pub type FlutterMetalTextureHandle = *const ::std::os::raw::c_void;
pub const FlutterMetalExternalTexturePixelFormat_kYUVA: FlutterMetalExternalTexturePixelFormat = 0;
pub const FlutterMetalExternalTexturePixelFormat_kRGBA: FlutterMetalExternalTexturePixelFormat = 1;
#[doc = " Pixel format for the external texture."]
pub type FlutterMetalExternalTexturePixelFormat = ::std::os::raw::c_int;
pub const FlutterMetalExternalTextureYUVColorSpace_kBT601FullRange:
    FlutterMetalExternalTextureYUVColorSpace = 0;
pub const FlutterMetalExternalTextureYUVColorSpace_kBT601LimitedRange:
    FlutterMetalExternalTextureYUVColorSpace = 1;
#[doc = " YUV color space for the YUV external texture."]
pub type FlutterMetalExternalTextureYUVColorSpace = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalExternalTexture {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalExternalTexture)."]
    pub struct_size: usize,
    #[doc = " Height of the texture."]
    pub width: usize,
    #[doc = " Height of the texture."]
    pub height: usize,
    #[doc = " The pixel format type of the external."]
    pub pixel_format: FlutterMetalExternalTexturePixelFormat,
    #[doc = " Represents the size of the `textures` array."]
    pub num_textures: usize,
    #[doc = " Supported textures are YUVA and RGBA, in case of YUVA we expect 2 texture\n handles to be provided by the embedder, Y first and UV next. In case of\n RGBA only one should be passed.\n These are individually aliases for id<MTLTexture>. These textures are\n retained by the engine for the period of the composition. Once these\n textures have been unregistered via the\n `FlutterEngineUnregisterExternalTexture`, the embedder has to release\n these textures."]
    pub textures: *mut FlutterMetalTextureHandle,
    #[doc = " The YUV color space of the YUV external texture."]
    pub yuv_color_space: FlutterMetalExternalTextureYUVColorSpace,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalExternalTexture"]
        [::std::mem::size_of::<FlutterMetalExternalTexture>() - 56usize];
    ["Alignment of FlutterMetalExternalTexture"]
        [::std::mem::align_of::<FlutterMetalExternalTexture>() - 8usize];
    ["Offset of field: FlutterMetalExternalTexture::struct_size"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, struct_size) - 0usize];
    ["Offset of field: FlutterMetalExternalTexture::width"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, width) - 8usize];
    ["Offset of field: FlutterMetalExternalTexture::height"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, height) - 16usize];
    ["Offset of field: FlutterMetalExternalTexture::pixel_format"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, pixel_format) - 24usize];
    ["Offset of field: FlutterMetalExternalTexture::num_textures"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, num_textures) - 32usize];
    ["Offset of field: FlutterMetalExternalTexture::textures"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, textures) - 40usize];
    ["Offset of field: FlutterMetalExternalTexture::yuv_color_space"]
        [::std::mem::offset_of!(FlutterMetalExternalTexture, yuv_color_space) - 48usize];
};
impl Default for FlutterMetalExternalTexture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback to provide an external texture for a given texture_id.\n See: external_texture_frame_callback."]
pub type FlutterMetalTextureFrameCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: i64,
        arg3: usize,
        arg4: usize,
        arg5: *mut FlutterMetalExternalTexture,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalTexture {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalTexture)."]
    pub struct_size: usize,
    #[doc = " Embedder provided unique identifier to the texture buffer. Given that the\n `texture` handle is passed to the engine to render to, the texture buffer\n is itself owned by the embedder. This `texture_id` is then also given to\n the embedder in the present callback."]
    pub texture_id: i64,
    #[doc = " Handle to the MTLTexture that is owned by the embedder. Engine will render\n the frame into this texture.\n\n A NULL texture is considered invalid."]
    pub texture: FlutterMetalTextureHandle,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalTexture"][::std::mem::size_of::<FlutterMetalTexture>() - 40usize];
    ["Alignment of FlutterMetalTexture"][::std::mem::align_of::<FlutterMetalTexture>() - 8usize];
    ["Offset of field: FlutterMetalTexture::struct_size"]
        [::std::mem::offset_of!(FlutterMetalTexture, struct_size) - 0usize];
    ["Offset of field: FlutterMetalTexture::texture_id"]
        [::std::mem::offset_of!(FlutterMetalTexture, texture_id) - 8usize];
    ["Offset of field: FlutterMetalTexture::texture"]
        [::std::mem::offset_of!(FlutterMetalTexture, texture) - 16usize];
    ["Offset of field: FlutterMetalTexture::user_data"]
        [::std::mem::offset_of!(FlutterMetalTexture, user_data) - 24usize];
    ["Offset of field: FlutterMetalTexture::destruction_callback"]
        [::std::mem::offset_of!(FlutterMetalTexture, destruction_callback) - 32usize];
};
impl Default for FlutterMetalTexture {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback for when a metal texture is requested."]
pub type FlutterMetalTextureCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterFrameInfo,
    ) -> FlutterMetalTexture,
>;
#[doc = " Callback for when a metal texture is presented. The texture_id here\n corresponds to the texture_id provided by the embedder in the\n `FlutterMetalTextureCallback` callback."]
pub type FlutterMetalPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterMetalTexture,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterMetalRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalRendererConfig)."]
    pub struct_size: usize,
    #[doc = " Alias for id<MTLDevice>."]
    pub device: FlutterMetalDeviceHandle,
    #[doc = " Alias for id<MTLCommandQueue>."]
    pub present_command_queue: FlutterMetalCommandQueueHandle,
    #[doc = " The callback that gets invoked when the engine requests the embedder for a\n texture to render to.\n\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub get_next_drawable_callback: FlutterMetalTextureCallback,
    #[doc = " The callback presented to the embedder to present a fully populated metal\n texture to the user.\n\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub present_drawable_callback: FlutterMetalPresentCallback,
    #[doc = " When the embedder specifies that a texture has a frame available, the\n engine will call this method (on an internal engine managed thread) so\n that external texture details can be supplied to the engine for subsequent\n composition."]
    pub external_texture_frame_callback: FlutterMetalTextureFrameCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalRendererConfig"]
        [::std::mem::size_of::<FlutterMetalRendererConfig>() - 48usize];
    ["Alignment of FlutterMetalRendererConfig"]
        [::std::mem::align_of::<FlutterMetalRendererConfig>() - 8usize];
    ["Offset of field: FlutterMetalRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterMetalRendererConfig::device"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, device) - 8usize];
    ["Offset of field: FlutterMetalRendererConfig::present_command_queue"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, present_command_queue) - 16usize];
    ["Offset of field: FlutterMetalRendererConfig::get_next_drawable_callback"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, get_next_drawable_callback) - 24usize];
    ["Offset of field: FlutterMetalRendererConfig::present_drawable_callback"]
        [::std::mem::offset_of!(FlutterMetalRendererConfig, present_drawable_callback) - 32usize];
    ["Offset of field: FlutterMetalRendererConfig::external_texture_frame_callback"][::std::mem::offset_of!(
        FlutterMetalRendererConfig,
        external_texture_frame_callback
    ) - 40usize];
};
impl Default for FlutterMetalRendererConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Alias for VkInstance."]
pub type FlutterVulkanInstanceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkPhysicalDevice."]
pub type FlutterVulkanPhysicalDeviceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkDevice."]
pub type FlutterVulkanDeviceHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkQueue."]
pub type FlutterVulkanQueueHandle = *mut ::std::os::raw::c_void;
#[doc = " Alias for VkImage."]
pub type FlutterVulkanImageHandle = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterVulkanImage {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanImage)."]
    pub struct_size: usize,
    #[doc = " Handle to the VkImage that is owned by the embedder. The engine will\n bind this image for writing the frame."]
    pub image: FlutterVulkanImageHandle,
    #[doc = " The VkFormat of the image (for example: VK_FORMAT_R8G8B8A8_UNORM)."]
    pub format: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanImage"][::std::mem::size_of::<FlutterVulkanImage>() - 24usize];
    ["Alignment of FlutterVulkanImage"][::std::mem::align_of::<FlutterVulkanImage>() - 8usize];
    ["Offset of field: FlutterVulkanImage::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanImage, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanImage::image"]
        [::std::mem::offset_of!(FlutterVulkanImage, image) - 8usize];
    ["Offset of field: FlutterVulkanImage::format"]
        [::std::mem::offset_of!(FlutterVulkanImage, format) - 16usize];
};
#[doc = " Callback to fetch a Vulkan function pointer for a given instance. Normally,\n this should return the results of vkGetInstanceProcAddr."]
pub type FlutterVulkanInstanceProcAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: FlutterVulkanInstanceHandle,
        arg3: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Callback for when a VkImage is requested."]
pub type FlutterVulkanImageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterFrameInfo,
    ) -> FlutterVulkanImage,
>;
#[doc = " Callback for when a VkImage has been written to and is ready for use by the\n embedder."]
pub type FlutterVulkanPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const FlutterVulkanImage,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterVulkanRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanRendererConfig)."]
    pub struct_size: usize,
    #[doc = " The Vulkan API version. This should match the value set in\n VkApplicationInfo::apiVersion when the VkInstance was created."]
    pub version: u32,
    #[doc = " VkInstance handle. Must not be destroyed before `FlutterEngineShutdown` is\n called."]
    pub instance: FlutterVulkanInstanceHandle,
    #[doc = " VkPhysicalDevice handle."]
    pub physical_device: FlutterVulkanPhysicalDeviceHandle,
    #[doc = " VkDevice handle. Must not be destroyed before `FlutterEngineShutdown` is\n called."]
    pub device: FlutterVulkanDeviceHandle,
    #[doc = " The queue family index of the VkQueue supplied in the next field."]
    pub queue_family_index: u32,
    #[doc = " VkQueue handle.\n The queue should not be used without protection from a mutex to make sure\n it is not used simultaneously with other threads. That mutex should match\n the one injected via the |get_instance_proc_address_callback|.\n There is a proposal to remove the need for the mutex at\n https://github.com/flutter/flutter/issues/134573."]
    pub queue: FlutterVulkanQueueHandle,
    #[doc = " The number of instance extensions available for enumerating in the next\n field."]
    pub enabled_instance_extension_count: usize,
    #[doc = " Array of enabled instance extension names. This should match the names\n passed to `VkInstanceCreateInfo.ppEnabledExtensionNames` when the instance\n was created, but any subset of enabled instance extensions may be\n specified.\n This field is optional; `nullptr` may be specified.\n This memory is only accessed during the call to FlutterEngineInitialize."]
    pub enabled_instance_extensions: *mut *const ::std::os::raw::c_char,
    #[doc = " The number of device extensions available for enumerating in the next\n field."]
    pub enabled_device_extension_count: usize,
    #[doc = " Array of enabled logical device extension names. This should match the\n names passed to `VkDeviceCreateInfo.ppEnabledExtensionNames` when the\n logical device was created, but any subset of enabled logical device\n extensions may be specified.\n This field is optional; `nullptr` may be specified.\n This memory is only accessed during the call to FlutterEngineInitialize.\n For example: VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME"]
    pub enabled_device_extensions: *mut *const ::std::os::raw::c_char,
    #[doc = " The callback invoked when resolving Vulkan function pointers.\n At a bare minimum this should be used to swap out any calls that operate\n on vkQueue's for threadsafe variants that obtain locks for their duration.\n The functions to swap out are \"vkQueueSubmit\" and \"vkQueueWaitIdle\".  An\n example of how to do that can be found in the test\n \"EmbedderTest.CanSwapOutVulkanCalls\" unit-test in\n //shell/platform/embedder/tests/embedder_vk_unittests.cc."]
    pub get_instance_proc_address_callback: FlutterVulkanInstanceProcAddressCallback,
    #[doc = " The callback invoked when the engine requests a VkImage from the embedder\n for rendering the next frame.\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub get_next_image_callback: FlutterVulkanImageCallback,
    #[doc = " The callback invoked when a VkImage has been written to and is ready for\n use by the embedder. Prior to calling this callback, the engine performs\n a host sync, and so the VkImage can be used in a pipeline by the embedder\n without any additional synchronization.\n Not used if a FlutterCompositor is supplied in FlutterProjectArgs."]
    pub present_image_callback: FlutterVulkanPresentCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanRendererConfig"]
        [::std::mem::size_of::<FlutterVulkanRendererConfig>() - 112usize];
    ["Alignment of FlutterVulkanRendererConfig"]
        [::std::mem::align_of::<FlutterVulkanRendererConfig>() - 8usize];
    ["Offset of field: FlutterVulkanRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanRendererConfig::version"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, version) - 8usize];
    ["Offset of field: FlutterVulkanRendererConfig::instance"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, instance) - 16usize];
    ["Offset of field: FlutterVulkanRendererConfig::physical_device"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, physical_device) - 24usize];
    ["Offset of field: FlutterVulkanRendererConfig::device"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, device) - 32usize];
    ["Offset of field: FlutterVulkanRendererConfig::queue_family_index"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, queue_family_index) - 40usize];
    ["Offset of field: FlutterVulkanRendererConfig::queue"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, queue) - 48usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_instance_extension_count"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_instance_extension_count
    ) - 56usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_instance_extensions"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_instance_extensions
    ) - 64usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_device_extension_count"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        enabled_device_extension_count
    ) - 72usize];
    ["Offset of field: FlutterVulkanRendererConfig::enabled_device_extensions"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, enabled_device_extensions) - 80usize];
    ["Offset of field: FlutterVulkanRendererConfig::get_instance_proc_address_callback"][::std::mem::offset_of!(
        FlutterVulkanRendererConfig,
        get_instance_proc_address_callback
    )
        - 88usize];
    ["Offset of field: FlutterVulkanRendererConfig::get_next_image_callback"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, get_next_image_callback) - 96usize];
    ["Offset of field: FlutterVulkanRendererConfig::present_image_callback"]
        [::std::mem::offset_of!(FlutterVulkanRendererConfig, present_image_callback) - 104usize];
};
impl Default for FlutterVulkanRendererConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterSoftwareRendererConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterSoftwareRendererConfig)."]
    pub struct_size: usize,
    #[doc = " The callback presented to the embedder to present a fully populated buffer\n to the user. The pixel format of the buffer is the native 32-bit RGBA\n format. The buffer is owned by the Flutter engine and must be copied in\n this callback if needed."]
    pub surface_present_callback: SoftwareSurfacePresentCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareRendererConfig"]
        [::std::mem::size_of::<FlutterSoftwareRendererConfig>() - 16usize];
    ["Alignment of FlutterSoftwareRendererConfig"]
        [::std::mem::align_of::<FlutterSoftwareRendererConfig>() - 8usize];
    ["Offset of field: FlutterSoftwareRendererConfig::struct_size"]
        [::std::mem::offset_of!(FlutterSoftwareRendererConfig, struct_size) - 0usize];
    ["Offset of field: FlutterSoftwareRendererConfig::surface_present_callback"]
        [::std::mem::offset_of!(FlutterSoftwareRendererConfig, surface_present_callback) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterRendererConfig {
    pub type_: FlutterRendererType,
    pub __bindgen_anon_1: FlutterRendererConfig__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterRendererConfig__bindgen_ty_1 {
    pub open_gl: FlutterOpenGLRendererConfig,
    pub software: FlutterSoftwareRendererConfig,
    pub metal: FlutterMetalRendererConfig,
    pub vulkan: FlutterVulkanRendererConfig,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRendererConfig__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterRendererConfig__bindgen_ty_1>() - 112usize];
    ["Alignment of FlutterRendererConfig__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterRendererConfig__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::open_gl"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, open_gl) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::software"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, software) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::metal"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, metal) - 0usize];
    ["Offset of field: FlutterRendererConfig__bindgen_ty_1::vulkan"]
        [::std::mem::offset_of!(FlutterRendererConfig__bindgen_ty_1, vulkan) - 0usize];
};
impl Default for FlutterRendererConfig__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRendererConfig"][::std::mem::size_of::<FlutterRendererConfig>() - 120usize];
    ["Alignment of FlutterRendererConfig"]
        [::std::mem::align_of::<FlutterRendererConfig>() - 8usize];
    ["Offset of field: FlutterRendererConfig::type_"]
        [::std::mem::offset_of!(FlutterRendererConfig, type_) - 0usize];
};
impl Default for FlutterRendererConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Display refers to a graphics hardware system consisting of a framebuffer,\n typically a monitor or a screen. This ID is unique per display and is\n stable until the Flutter application restarts."]
pub type FlutterEngineDisplayId = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterWindowMetricsEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterWindowMetricsEvent)."]
    pub struct_size: usize,
    #[doc = " Physical width of the window."]
    pub width: usize,
    #[doc = " Physical height of the window."]
    pub height: usize,
    #[doc = " Scale factor for the physical screen."]
    pub pixel_ratio: f64,
    #[doc = " Horizontal physical location of the left side of the window on the screen."]
    pub left: usize,
    #[doc = " Vertical physical location of the top of the window on the screen."]
    pub top: usize,
    #[doc = " Top inset of window."]
    pub physical_view_inset_top: f64,
    #[doc = " Right inset of window."]
    pub physical_view_inset_right: f64,
    #[doc = " Bottom inset of window."]
    pub physical_view_inset_bottom: f64,
    #[doc = " Left inset of window."]
    pub physical_view_inset_left: f64,
    #[doc = " The identifier of the display the view is rendering on."]
    pub display_id: FlutterEngineDisplayId,
    #[doc = " The view that this event is describing."]
    pub view_id: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterWindowMetricsEvent"]
        [::std::mem::size_of::<FlutterWindowMetricsEvent>() - 96usize];
    ["Alignment of FlutterWindowMetricsEvent"]
        [::std::mem::align_of::<FlutterWindowMetricsEvent>() - 8usize];
    ["Offset of field: FlutterWindowMetricsEvent::struct_size"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, struct_size) - 0usize];
    ["Offset of field: FlutterWindowMetricsEvent::width"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, width) - 8usize];
    ["Offset of field: FlutterWindowMetricsEvent::height"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, height) - 16usize];
    ["Offset of field: FlutterWindowMetricsEvent::pixel_ratio"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, pixel_ratio) - 24usize];
    ["Offset of field: FlutterWindowMetricsEvent::left"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, left) - 32usize];
    ["Offset of field: FlutterWindowMetricsEvent::top"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, top) - 40usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_top"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_top) - 48usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_right"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_right) - 56usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_bottom"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_bottom) - 64usize];
    ["Offset of field: FlutterWindowMetricsEvent::physical_view_inset_left"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, physical_view_inset_left) - 72usize];
    ["Offset of field: FlutterWindowMetricsEvent::display_id"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, display_id) - 80usize];
    ["Offset of field: FlutterWindowMetricsEvent::view_id"]
        [::std::mem::offset_of!(FlutterWindowMetricsEvent, view_id) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterAddViewResult {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterAddViewResult)."]
    pub struct_size: usize,
    #[doc = " True if the add view operation succeeded."]
    pub added: bool,
    #[doc = " The |FlutterAddViewInfo.user_data|."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterAddViewResult"][::std::mem::size_of::<FlutterAddViewResult>() - 24usize];
    ["Alignment of FlutterAddViewResult"][::std::mem::align_of::<FlutterAddViewResult>() - 8usize];
    ["Offset of field: FlutterAddViewResult::struct_size"]
        [::std::mem::offset_of!(FlutterAddViewResult, struct_size) - 0usize];
    ["Offset of field: FlutterAddViewResult::added"]
        [::std::mem::offset_of!(FlutterAddViewResult, added) - 8usize];
    ["Offset of field: FlutterAddViewResult::user_data"]
        [::std::mem::offset_of!(FlutterAddViewResult, user_data) - 16usize];
};
impl Default for FlutterAddViewResult {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The callback invoked by the engine when the engine has attempted to add a\n view.\n\n The |FlutterAddViewResult| is only guaranteed to be valid during this\n callback."]
pub type FlutterAddViewCallback =
    ::std::option::Option<unsafe extern "C" fn(result: *const FlutterAddViewResult)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterAddViewInfo {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterAddViewInfo)."]
    pub struct_size: usize,
    #[doc = " The identifier for the view to add. This must be unique."]
    pub view_id: FlutterViewId,
    #[doc = " The view's properties.\n\n The metric's |view_id| must match this struct's |view_id|."]
    pub view_metrics: *const FlutterWindowMetricsEvent,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in |add_view_callback|. Embedder resources may be\n associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Called once the engine has attempted to add the view. This callback is\n required.\n\n The embedder/app must not use the view until the callback is invoked with\n an `added` value of `true`.\n\n This callback is invoked on an internal engine managed thread. Embedders\n must re-thread if necessary."]
    pub add_view_callback: FlutterAddViewCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterAddViewInfo"][::std::mem::size_of::<FlutterAddViewInfo>() - 40usize];
    ["Alignment of FlutterAddViewInfo"][::std::mem::align_of::<FlutterAddViewInfo>() - 8usize];
    ["Offset of field: FlutterAddViewInfo::struct_size"]
        [::std::mem::offset_of!(FlutterAddViewInfo, struct_size) - 0usize];
    ["Offset of field: FlutterAddViewInfo::view_id"]
        [::std::mem::offset_of!(FlutterAddViewInfo, view_id) - 8usize];
    ["Offset of field: FlutterAddViewInfo::view_metrics"]
        [::std::mem::offset_of!(FlutterAddViewInfo, view_metrics) - 16usize];
    ["Offset of field: FlutterAddViewInfo::user_data"]
        [::std::mem::offset_of!(FlutterAddViewInfo, user_data) - 24usize];
    ["Offset of field: FlutterAddViewInfo::add_view_callback"]
        [::std::mem::offset_of!(FlutterAddViewInfo, add_view_callback) - 32usize];
};
impl Default for FlutterAddViewInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRemoveViewResult {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterRemoveViewResult)."]
    pub struct_size: usize,
    #[doc = " True if the remove view operation succeeded."]
    pub removed: bool,
    #[doc = " The |FlutterRemoveViewInfo.user_data|."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRemoveViewResult"][::std::mem::size_of::<FlutterRemoveViewResult>() - 24usize];
    ["Alignment of FlutterRemoveViewResult"]
        [::std::mem::align_of::<FlutterRemoveViewResult>() - 8usize];
    ["Offset of field: FlutterRemoveViewResult::struct_size"]
        [::std::mem::offset_of!(FlutterRemoveViewResult, struct_size) - 0usize];
    ["Offset of field: FlutterRemoveViewResult::removed"]
        [::std::mem::offset_of!(FlutterRemoveViewResult, removed) - 8usize];
    ["Offset of field: FlutterRemoveViewResult::user_data"]
        [::std::mem::offset_of!(FlutterRemoveViewResult, user_data) - 16usize];
};
impl Default for FlutterRemoveViewResult {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The callback invoked by the engine when the engine has attempted to remove\n a view.\n\n The |FlutterRemoveViewResult| is only guaranteed to be valid during this\n callback."]
pub type FlutterRemoveViewCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FlutterRemoveViewResult)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRemoveViewInfo {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterRemoveViewInfo)."]
    pub struct_size: usize,
    #[doc = " The identifier for the view to remove.\n\n The implicit view cannot be removed if it is enabled."]
    pub view_id: FlutterViewId,
    #[doc = " A baton that is not interpreted by the engine in any way.\n It will be given back to the embedder in |remove_view_callback|.\n Embedder resources may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Called once the engine has attempted to remove the view.\n This callback is required.\n\n The embedder must not destroy the underlying surface until the callback is\n invoked with a `removed` value of `true`.\n\n This callback is invoked on an internal engine managed thread.\n Embedders must re-thread if necessary.\n\n The |result| argument will be deallocated when the callback returns."]
    pub remove_view_callback: FlutterRemoveViewCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRemoveViewInfo"][::std::mem::size_of::<FlutterRemoveViewInfo>() - 32usize];
    ["Alignment of FlutterRemoveViewInfo"]
        [::std::mem::align_of::<FlutterRemoveViewInfo>() - 8usize];
    ["Offset of field: FlutterRemoveViewInfo::struct_size"]
        [::std::mem::offset_of!(FlutterRemoveViewInfo, struct_size) - 0usize];
    ["Offset of field: FlutterRemoveViewInfo::view_id"]
        [::std::mem::offset_of!(FlutterRemoveViewInfo, view_id) - 8usize];
    ["Offset of field: FlutterRemoveViewInfo::user_data"]
        [::std::mem::offset_of!(FlutterRemoveViewInfo, user_data) - 16usize];
    ["Offset of field: FlutterRemoveViewInfo::remove_view_callback"]
        [::std::mem::offset_of!(FlutterRemoveViewInfo, remove_view_callback) - 24usize];
};
impl Default for FlutterRemoveViewInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FlutterPointerPhase_kCancel: FlutterPointerPhase = 0;
#[doc = " The pointer, which must have been down (see kDown), is now up.\n\n For touch, this means that the pointer is no longer in contact with the\n screen. For a mouse, it means the last button was released. Note that if\n any other buttons are still pressed when one button is released, that\n should be sent as a kMove rather than a kUp."]
pub const FlutterPointerPhase_kUp: FlutterPointerPhase = 1;
#[doc = " The pointer, which must have been up, is now down.\n\n For touch, this means that the pointer has come into contact with the\n screen. For a mouse, it means a button is now pressed. Note that if any\n other buttons are already pressed when a new button is pressed, that\n should be sent as a kMove rather than a kDown."]
pub const FlutterPointerPhase_kDown: FlutterPointerPhase = 2;
#[doc = " The pointer moved while down.\n\n This is also used for changes in button state that don't cause a kDown or\n kUp, such as releasing one of two pressed buttons."]
pub const FlutterPointerPhase_kMove: FlutterPointerPhase = 3;
#[doc = " The pointer is now sending input to Flutter. For instance, a mouse has\n entered the area where the Flutter content is displayed.\n\n A pointer should always be added before sending any other events."]
pub const FlutterPointerPhase_kAdd: FlutterPointerPhase = 4;
#[doc = " The pointer is no longer sending input to Flutter. For instance, a mouse\n has left the area where the Flutter content is displayed.\n\n A removed pointer should no longer send events until sending a new kAdd."]
pub const FlutterPointerPhase_kRemove: FlutterPointerPhase = 5;
#[doc = " The pointer moved while up."]
pub const FlutterPointerPhase_kHover: FlutterPointerPhase = 6;
#[doc = " A pan/zoom started on this pointer."]
pub const FlutterPointerPhase_kPanZoomStart: FlutterPointerPhase = 7;
#[doc = " The pan/zoom updated."]
pub const FlutterPointerPhase_kPanZoomUpdate: FlutterPointerPhase = 8;
#[doc = " The pan/zoom ended."]
pub const FlutterPointerPhase_kPanZoomEnd: FlutterPointerPhase = 9;
#[doc = " The phase of the pointer event."]
pub type FlutterPointerPhase = ::std::os::raw::c_int;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindMouse: FlutterPointerDeviceKind = 1;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindTouch: FlutterPointerDeviceKind = 2;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindStylus: FlutterPointerDeviceKind = 3;
pub const FlutterPointerDeviceKind_kFlutterPointerDeviceKindTrackpad: FlutterPointerDeviceKind = 4;
#[doc = " The device type that created a pointer event."]
pub type FlutterPointerDeviceKind = ::std::os::raw::c_int;
pub const FlutterPointerMouseButtons_kFlutterPointerButtonMousePrimary: FlutterPointerMouseButtons =
    1;
pub const FlutterPointerMouseButtons_kFlutterPointerButtonMouseSecondary:
    FlutterPointerMouseButtons = 2;
pub const FlutterPointerMouseButtons_kFlutterPointerButtonMouseMiddle: FlutterPointerMouseButtons =
    4;
pub const FlutterPointerMouseButtons_kFlutterPointerButtonMouseBack: FlutterPointerMouseButtons = 8;
pub const FlutterPointerMouseButtons_kFlutterPointerButtonMouseForward: FlutterPointerMouseButtons =
    16;
#[doc = " Flags for the `buttons` field of `FlutterPointerEvent` when `device_kind`\n is `kFlutterPointerDeviceKindMouse`."]
pub type FlutterPointerMouseButtons = ::std::os::raw::c_int;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindNone: FlutterPointerSignalKind = 0;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScroll: FlutterPointerSignalKind = 1;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScrollInertiaCancel:
    FlutterPointerSignalKind = 2;
pub const FlutterPointerSignalKind_kFlutterPointerSignalKindScale: FlutterPointerSignalKind = 3;
#[doc = " The type of a pointer signal."]
pub type FlutterPointerSignalKind = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPointerEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterPointerEvent)."]
    pub struct_size: usize,
    pub phase: FlutterPointerPhase,
    #[doc = " The timestamp at which the pointer event was generated. The timestamp\n should be specified in microseconds and the clock should be the same as\n that used by `FlutterEngineGetCurrentTime`."]
    pub timestamp: usize,
    #[doc = " The x coordinate of the pointer event in physical pixels."]
    pub x: f64,
    #[doc = " The y coordinate of the pointer event in physical pixels."]
    pub y: f64,
    #[doc = " An optional device identifier. If this is not specified, it is assumed\n that the embedder has no multi-touch capability."]
    pub device: i32,
    pub signal_kind: FlutterPointerSignalKind,
    #[doc = " The x offset of the scroll in physical pixels."]
    pub scroll_delta_x: f64,
    #[doc = " The y offset of the scroll in physical pixels."]
    pub scroll_delta_y: f64,
    #[doc = " The type of the device generating this event.\n Backwards compatibility note: If this is not set, the device will be\n treated as a mouse, with the primary button set for `kDown` and `kMove`.\n If set explicitly to `kFlutterPointerDeviceKindMouse`, you must set the\n correct buttons."]
    pub device_kind: FlutterPointerDeviceKind,
    #[doc = " The buttons currently pressed, if any."]
    pub buttons: i64,
    #[doc = " The x offset of the pan/zoom in physical pixels."]
    pub pan_x: f64,
    #[doc = " The y offset of the pan/zoom in physical pixels."]
    pub pan_y: f64,
    #[doc = " The scale of the pan/zoom, where 1.0 is the initial scale."]
    pub scale: f64,
    #[doc = " The rotation of the pan/zoom in radians, where 0.0 is the initial angle."]
    pub rotation: f64,
    #[doc = " The identifier of the view that received the pointer event."]
    pub view_id: FlutterViewId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPointerEvent"][::std::mem::size_of::<FlutterPointerEvent>() - 120usize];
    ["Alignment of FlutterPointerEvent"][::std::mem::align_of::<FlutterPointerEvent>() - 8usize];
    ["Offset of field: FlutterPointerEvent::struct_size"]
        [::std::mem::offset_of!(FlutterPointerEvent, struct_size) - 0usize];
    ["Offset of field: FlutterPointerEvent::phase"]
        [::std::mem::offset_of!(FlutterPointerEvent, phase) - 8usize];
    ["Offset of field: FlutterPointerEvent::timestamp"]
        [::std::mem::offset_of!(FlutterPointerEvent, timestamp) - 16usize];
    ["Offset of field: FlutterPointerEvent::x"]
        [::std::mem::offset_of!(FlutterPointerEvent, x) - 24usize];
    ["Offset of field: FlutterPointerEvent::y"]
        [::std::mem::offset_of!(FlutterPointerEvent, y) - 32usize];
    ["Offset of field: FlutterPointerEvent::device"]
        [::std::mem::offset_of!(FlutterPointerEvent, device) - 40usize];
    ["Offset of field: FlutterPointerEvent::signal_kind"]
        [::std::mem::offset_of!(FlutterPointerEvent, signal_kind) - 44usize];
    ["Offset of field: FlutterPointerEvent::scroll_delta_x"]
        [::std::mem::offset_of!(FlutterPointerEvent, scroll_delta_x) - 48usize];
    ["Offset of field: FlutterPointerEvent::scroll_delta_y"]
        [::std::mem::offset_of!(FlutterPointerEvent, scroll_delta_y) - 56usize];
    ["Offset of field: FlutterPointerEvent::device_kind"]
        [::std::mem::offset_of!(FlutterPointerEvent, device_kind) - 64usize];
    ["Offset of field: FlutterPointerEvent::buttons"]
        [::std::mem::offset_of!(FlutterPointerEvent, buttons) - 72usize];
    ["Offset of field: FlutterPointerEvent::pan_x"]
        [::std::mem::offset_of!(FlutterPointerEvent, pan_x) - 80usize];
    ["Offset of field: FlutterPointerEvent::pan_y"]
        [::std::mem::offset_of!(FlutterPointerEvent, pan_y) - 88usize];
    ["Offset of field: FlutterPointerEvent::scale"]
        [::std::mem::offset_of!(FlutterPointerEvent, scale) - 96usize];
    ["Offset of field: FlutterPointerEvent::rotation"]
        [::std::mem::offset_of!(FlutterPointerEvent, rotation) - 104usize];
    ["Offset of field: FlutterPointerEvent::view_id"]
        [::std::mem::offset_of!(FlutterPointerEvent, view_id) - 112usize];
};
impl Default for FlutterPointerEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const FlutterKeyEventType_kFlutterKeyEventTypeUp: FlutterKeyEventType = 1;
pub const FlutterKeyEventType_kFlutterKeyEventTypeDown: FlutterKeyEventType = 2;
pub const FlutterKeyEventType_kFlutterKeyEventTypeRepeat: FlutterKeyEventType = 3;
pub type FlutterKeyEventType = ::std::os::raw::c_int;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeKeyboard: FlutterKeyEventDeviceType =
    1;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeDirectionalPad:
    FlutterKeyEventDeviceType = 2;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeGamepad: FlutterKeyEventDeviceType =
    3;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeJoystick: FlutterKeyEventDeviceType =
    4;
pub const FlutterKeyEventDeviceType_kFlutterKeyEventDeviceTypeHdmi: FlutterKeyEventDeviceType = 5;
pub type FlutterKeyEventDeviceType = ::std::os::raw::c_int;
#[doc = " A structure to represent a key event.\n\n Sending `FlutterKeyEvent` via `FlutterEngineSendKeyEvent` results in a\n corresponding `FlutterKeyEvent` to be dispatched in the framework. It is\n embedder's responsibility to ensure the regularity of sent events, since the\n framework only performs simple one-to-one mapping. The events must conform\n the following rules:\n\n  * Each key press sequence shall consist of one key down event (`kind` being\n    `kFlutterKeyEventTypeDown`), zero or more repeat events, and one key up\n    event, representing a physical key button being pressed, held, and\n    released.\n  * All events throughout a key press sequence shall have the same `physical`\n    and `logical`. Having different `character`s is allowed.\n\n A `FlutterKeyEvent` with `physical` 0 and `logical` 0 is an empty event.\n This is the only case either `physical` or `logical` can be 0. An empty\n event must be sent if a key message should be converted to no\n `FlutterKeyEvent`s, for example, when a key down message is received for a\n key that has already been pressed according to the record. This is to ensure\n some `FlutterKeyEvent` arrives at the framework before raw key message.\n See https://github.com/flutter/flutter/issues/87230."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterKeyEvent {
    #[doc = " The size of this struct. Must be sizeof(FlutterKeyEvent)."]
    pub struct_size: usize,
    #[doc = " The timestamp at which the key event was generated. The timestamp should\n be specified in microseconds and the clock should be the same as that used\n by `FlutterEngineGetCurrentTime`."]
    pub timestamp: f64,
    #[doc = " The event kind."]
    pub type_: FlutterKeyEventType,
    #[doc = " The USB HID code for the physical key of the event.\n\n For the full definition and list of pre-defined physical keys, see\n `PhysicalKeyboardKey` from the framework.\n\n The only case that `physical` might be 0 is when this is an empty event.\n See `FlutterKeyEvent` for introduction."]
    pub physical: u64,
    #[doc = " The key ID for the logical key of this event.\n\n For the full definition and a list of pre-defined logical keys, see\n `LogicalKeyboardKey` from the framework.\n\n The only case that `logical` might be 0 is when this is an empty event.\n See `FlutterKeyEvent` for introduction."]
    pub logical: u64,
    #[doc = " Null-terminated character input from the event. Can be null. Ignored for\n up events."]
    pub character: *const ::std::os::raw::c_char,
    #[doc = " True if this event does not correspond to a native event.\n\n The embedder is likely to skip events and/or construct new events that do\n not correspond to any native events in order to conform the regularity\n of events (as documented in `FlutterKeyEvent`). An example is when a key\n up is missed due to loss of window focus, on a platform that provides\n query to key pressing status, the embedder might realize that the key has\n been released at the next key event, and should construct a synthesized up\n event immediately before the actual event.\n\n An event being synthesized means that the `timestamp` might greatly\n deviate from the actual time when the event occurs physically."]
    pub synthesized: bool,
    #[doc = " The source device for the key event."]
    pub device_type: FlutterKeyEventDeviceType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterKeyEvent"][::std::mem::size_of::<FlutterKeyEvent>() - 56usize];
    ["Alignment of FlutterKeyEvent"][::std::mem::align_of::<FlutterKeyEvent>() - 8usize];
    ["Offset of field: FlutterKeyEvent::struct_size"]
        [::std::mem::offset_of!(FlutterKeyEvent, struct_size) - 0usize];
    ["Offset of field: FlutterKeyEvent::timestamp"]
        [::std::mem::offset_of!(FlutterKeyEvent, timestamp) - 8usize];
    ["Offset of field: FlutterKeyEvent::type_"]
        [::std::mem::offset_of!(FlutterKeyEvent, type_) - 16usize];
    ["Offset of field: FlutterKeyEvent::physical"]
        [::std::mem::offset_of!(FlutterKeyEvent, physical) - 24usize];
    ["Offset of field: FlutterKeyEvent::logical"]
        [::std::mem::offset_of!(FlutterKeyEvent, logical) - 32usize];
    ["Offset of field: FlutterKeyEvent::character"]
        [::std::mem::offset_of!(FlutterKeyEvent, character) - 40usize];
    ["Offset of field: FlutterKeyEvent::synthesized"]
        [::std::mem::offset_of!(FlutterKeyEvent, synthesized) - 48usize];
    ["Offset of field: FlutterKeyEvent::device_type"]
        [::std::mem::offset_of!(FlutterKeyEvent, device_type) - 52usize];
};
impl Default for FlutterKeyEvent {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterKeyEventCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: bool, arg2: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterPlatformMessageResponseHandle {
    _unused: [u8; 0],
}
pub type FlutterPlatformMessageResponseHandle = _FlutterPlatformMessageResponseHandle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPlatformMessage {
    #[doc = " The size of this struct. Must be sizeof(FlutterPlatformMessage)."]
    pub struct_size: usize,
    pub channel: *const ::std::os::raw::c_char,
    pub message: *const u8,
    pub message_size: usize,
    #[doc = " The response handle on which to invoke\n `FlutterEngineSendPlatformMessageResponse` when the response is ready.\n `FlutterEngineSendPlatformMessageResponse` must be called for all messages\n received by the embedder. Failure to call\n `FlutterEngineSendPlatformMessageResponse` will cause a memory leak. It is\n not safe to send multiple responses on a single response object."]
    pub response_handle: *const FlutterPlatformMessageResponseHandle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformMessage"][::std::mem::size_of::<FlutterPlatformMessage>() - 40usize];
    ["Alignment of FlutterPlatformMessage"]
        [::std::mem::align_of::<FlutterPlatformMessage>() - 8usize];
    ["Offset of field: FlutterPlatformMessage::struct_size"]
        [::std::mem::offset_of!(FlutterPlatformMessage, struct_size) - 0usize];
    ["Offset of field: FlutterPlatformMessage::channel"]
        [::std::mem::offset_of!(FlutterPlatformMessage, channel) - 8usize];
    ["Offset of field: FlutterPlatformMessage::message"]
        [::std::mem::offset_of!(FlutterPlatformMessage, message) - 16usize];
    ["Offset of field: FlutterPlatformMessage::message_size"]
        [::std::mem::offset_of!(FlutterPlatformMessage, message_size) - 24usize];
    ["Offset of field: FlutterPlatformMessage::response_handle"]
        [::std::mem::offset_of!(FlutterPlatformMessage, response_handle) - 32usize];
};
impl Default for FlutterPlatformMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterPlatformMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterPlatformMessage, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterDataCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const u8, arg2: usize, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " The identifier of the platform view. This identifier is specified by the\n application when a platform view is added to the scene via the\n `SceneBuilder.addPlatformView` call."]
pub type FlutterPlatformViewIdentifier = i64;
unsafe extern "C" {
    #[doc = " `FlutterSemanticsNode` ID used as a sentinel to signal the end of a batch of\n semantics node updates. This is unused if using\n `FlutterUpdateSemanticsCallback2`."]
    pub static kFlutterSemanticsNodeIdBatchEnd: i32;
}
pub const FlutterStringAttributeType_kSpellOut: FlutterStringAttributeType = 0;
pub const FlutterStringAttributeType_kLocale: FlutterStringAttributeType = 1;
pub type FlutterStringAttributeType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterSpellOutStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterSpellOutStringAttribute)."]
    pub struct_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSpellOutStringAttribute"]
        [::std::mem::size_of::<FlutterSpellOutStringAttribute>() - 8usize];
    ["Alignment of FlutterSpellOutStringAttribute"]
        [::std::mem::align_of::<FlutterSpellOutStringAttribute>() - 8usize];
    ["Offset of field: FlutterSpellOutStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterSpellOutStringAttribute, struct_size) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterLocaleStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterLocaleStringAttribute)."]
    pub struct_size: usize,
    pub locale: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLocaleStringAttribute"]
        [::std::mem::size_of::<FlutterLocaleStringAttribute>() - 16usize];
    ["Alignment of FlutterLocaleStringAttribute"]
        [::std::mem::align_of::<FlutterLocaleStringAttribute>() - 8usize];
    ["Offset of field: FlutterLocaleStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterLocaleStringAttribute, struct_size) - 0usize];
    ["Offset of field: FlutterLocaleStringAttribute::locale"]
        [::std::mem::offset_of!(FlutterLocaleStringAttribute, locale) - 8usize];
};
impl Default for FlutterLocaleStringAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterStringAttribute {
    #[doc = " The size of this struct. Must be sizeof(FlutterStringAttribute)."]
    pub struct_size: usize,
    pub start: usize,
    pub end: usize,
    #[doc = " The type of the attribute described by the subsequent union."]
    pub type_: FlutterStringAttributeType,
    pub __bindgen_anon_1: FlutterStringAttribute__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterStringAttribute__bindgen_ty_1 {
    pub spell_out: *const FlutterSpellOutStringAttribute,
    pub locale: *const FlutterLocaleStringAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterStringAttribute__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterStringAttribute__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterStringAttribute__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterStringAttribute__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterStringAttribute__bindgen_ty_1::spell_out"]
        [::std::mem::offset_of!(FlutterStringAttribute__bindgen_ty_1, spell_out) - 0usize];
    ["Offset of field: FlutterStringAttribute__bindgen_ty_1::locale"]
        [::std::mem::offset_of!(FlutterStringAttribute__bindgen_ty_1, locale) - 0usize];
};
impl Default for FlutterStringAttribute__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterStringAttribute"][::std::mem::size_of::<FlutterStringAttribute>() - 40usize];
    ["Alignment of FlutterStringAttribute"]
        [::std::mem::align_of::<FlutterStringAttribute>() - 8usize];
    ["Offset of field: FlutterStringAttribute::struct_size"]
        [::std::mem::offset_of!(FlutterStringAttribute, struct_size) - 0usize];
    ["Offset of field: FlutterStringAttribute::start"]
        [::std::mem::offset_of!(FlutterStringAttribute, start) - 8usize];
    ["Offset of field: FlutterStringAttribute::end"]
        [::std::mem::offset_of!(FlutterStringAttribute, end) - 16usize];
    ["Offset of field: FlutterStringAttribute::type_"]
        [::std::mem::offset_of!(FlutterStringAttribute, type_) - 24usize];
};
impl Default for FlutterStringAttribute {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A node that represents some semantic data.\n\n The semantics tree is maintained during the semantics phase of the pipeline\n (i.e., during PipelineOwner.flushSemantics), which happens after\n compositing. Updates are then pushed to embedders via the registered\n `FlutterUpdateSemanticsCallback`.\n\n @deprecated     Use `FlutterSemanticsNode2` instead. In order to preserve\n                 ABI compatibility for existing users, no new fields will be\n                 added to this struct. New fields will continue to be added\n                 to `FlutterSemanticsNode2`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsNode {
    #[doc = " The size of this struct. Must be sizeof(FlutterSemanticsNode)."]
    pub struct_size: usize,
    #[doc = " The unique identifier for this node."]
    pub id: i32,
    #[doc = " The set of semantics flags associated with this node."]
    pub flags: FlutterSemanticsFlag,
    #[doc = " The set of semantics actions applicable to this node."]
    pub actions: FlutterSemanticsAction,
    #[doc = " The position at which the text selection originates."]
    pub text_selection_base: i32,
    #[doc = " The position at which the text selection terminates."]
    pub text_selection_extent: i32,
    #[doc = " The total number of scrollable children that contribute to semantics."]
    pub scroll_child_count: i32,
    #[doc = " The index of the first visible semantic child of a scroll node."]
    pub scroll_index: i32,
    #[doc = " The current scrolling position in logical pixels if the node is\n scrollable."]
    pub scroll_position: f64,
    #[doc = " The maximum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_max: f64,
    #[doc = " The minimum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_min: f64,
    #[doc = " The elevation along the z-axis at which the rect of this semantics node is\n located above its parent."]
    pub elevation: f64,
    #[doc = " Describes how much space the semantics node takes up along the z-axis."]
    pub thickness: f64,
    #[doc = " A textual description of the node."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " A brief description of the result of performing an action on the node."]
    pub hint: *const ::std::os::raw::c_char,
    #[doc = " A textual description of the current value of the node."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionIncrease`\n action has been performed."]
    pub increased_value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionDecrease`\n action has been performed."]
    pub decreased_value: *const ::std::os::raw::c_char,
    #[doc = " The reading direction for `label`, `value`, `hint`, `increasedValue`,\n `decreasedValue`, and `tooltip`."]
    pub text_direction: FlutterTextDirection,
    #[doc = " The bounding box for this node in its coordinate system."]
    pub rect: FlutterRect,
    #[doc = " The transform from this node's coordinate system to its parent's\n coordinate system."]
    pub transform: FlutterTransformation,
    #[doc = " The number of children this node has."]
    pub child_count: usize,
    #[doc = " Array of child node IDs in traversal order. Has length `child_count`."]
    pub children_in_traversal_order: *const i32,
    #[doc = " Array of child node IDs in hit test order. Has length `child_count`."]
    pub children_in_hit_test_order: *const i32,
    #[doc = " The number of custom accessibility action associated with this node."]
    pub custom_accessibility_actions_count: usize,
    #[doc = " Array of `FlutterSemanticsCustomAction` IDs associated with this node.\n Has length `custom_accessibility_actions_count`."]
    pub custom_accessibility_actions: *const i32,
    #[doc = " Identifier of the platform view associated with this semantics node, or\n -1 if none."]
    pub platform_view_id: FlutterPlatformViewIdentifier,
    #[doc = " A textual tooltip attached to the node."]
    pub tooltip: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsNode"][::std::mem::size_of::<FlutterSemanticsNode>() - 288usize];
    ["Alignment of FlutterSemanticsNode"][::std::mem::align_of::<FlutterSemanticsNode>() - 8usize];
    ["Offset of field: FlutterSemanticsNode::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsNode, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsNode::id"]
        [::std::mem::offset_of!(FlutterSemanticsNode, id) - 8usize];
    ["Offset of field: FlutterSemanticsNode::flags"]
        [::std::mem::offset_of!(FlutterSemanticsNode, flags) - 12usize];
    ["Offset of field: FlutterSemanticsNode::actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode, actions) - 16usize];
    ["Offset of field: FlutterSemanticsNode::text_selection_base"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_selection_base) - 20usize];
    ["Offset of field: FlutterSemanticsNode::text_selection_extent"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_selection_extent) - 24usize];
    ["Offset of field: FlutterSemanticsNode::scroll_child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_child_count) - 28usize];
    ["Offset of field: FlutterSemanticsNode::scroll_index"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_index) - 32usize];
    ["Offset of field: FlutterSemanticsNode::scroll_position"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_position) - 40usize];
    ["Offset of field: FlutterSemanticsNode::scroll_extent_max"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_extent_max) - 48usize];
    ["Offset of field: FlutterSemanticsNode::scroll_extent_min"]
        [::std::mem::offset_of!(FlutterSemanticsNode, scroll_extent_min) - 56usize];
    ["Offset of field: FlutterSemanticsNode::elevation"]
        [::std::mem::offset_of!(FlutterSemanticsNode, elevation) - 64usize];
    ["Offset of field: FlutterSemanticsNode::thickness"]
        [::std::mem::offset_of!(FlutterSemanticsNode, thickness) - 72usize];
    ["Offset of field: FlutterSemanticsNode::label"]
        [::std::mem::offset_of!(FlutterSemanticsNode, label) - 80usize];
    ["Offset of field: FlutterSemanticsNode::hint"]
        [::std::mem::offset_of!(FlutterSemanticsNode, hint) - 88usize];
    ["Offset of field: FlutterSemanticsNode::value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, value) - 96usize];
    ["Offset of field: FlutterSemanticsNode::increased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, increased_value) - 104usize];
    ["Offset of field: FlutterSemanticsNode::decreased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode, decreased_value) - 112usize];
    ["Offset of field: FlutterSemanticsNode::text_direction"]
        [::std::mem::offset_of!(FlutterSemanticsNode, text_direction) - 120usize];
    ["Offset of field: FlutterSemanticsNode::rect"]
        [::std::mem::offset_of!(FlutterSemanticsNode, rect) - 128usize];
    ["Offset of field: FlutterSemanticsNode::transform"]
        [::std::mem::offset_of!(FlutterSemanticsNode, transform) - 160usize];
    ["Offset of field: FlutterSemanticsNode::child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode, child_count) - 232usize];
    ["Offset of field: FlutterSemanticsNode::children_in_traversal_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode, children_in_traversal_order) - 240usize];
    ["Offset of field: FlutterSemanticsNode::children_in_hit_test_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode, children_in_hit_test_order) - 248usize];
    ["Offset of field: FlutterSemanticsNode::custom_accessibility_actions_count"][::std::mem::offset_of!(
        FlutterSemanticsNode,
        custom_accessibility_actions_count
    ) - 256usize];
    ["Offset of field: FlutterSemanticsNode::custom_accessibility_actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode, custom_accessibility_actions) - 264usize];
    ["Offset of field: FlutterSemanticsNode::platform_view_id"]
        [::std::mem::offset_of!(FlutterSemanticsNode, platform_view_id) - 272usize];
    ["Offset of field: FlutterSemanticsNode::tooltip"]
        [::std::mem::offset_of!(FlutterSemanticsNode, tooltip) - 280usize];
};
impl Default for FlutterSemanticsNode {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A node in the Flutter semantics tree.\n\n The semantics tree is maintained during the semantics phase of the pipeline\n (i.e., during PipelineOwner.flushSemantics), which happens after\n compositing. Updates are then pushed to embedders via the registered\n `FlutterUpdateSemanticsCallback2`.\n\n @see https://api.flutter.dev/flutter/semantics/SemanticsNode-class.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsNode2 {
    #[doc = " The size of this struct. Must be sizeof(FlutterSemanticsNode)."]
    pub struct_size: usize,
    #[doc = " The unique identifier for this node."]
    pub id: i32,
    #[doc = " The set of semantics flags associated with this node."]
    pub flags: FlutterSemanticsFlag,
    #[doc = " The set of semantics actions applicable to this node."]
    pub actions: FlutterSemanticsAction,
    #[doc = " The position at which the text selection originates."]
    pub text_selection_base: i32,
    #[doc = " The position at which the text selection terminates."]
    pub text_selection_extent: i32,
    #[doc = " The total number of scrollable children that contribute to semantics."]
    pub scroll_child_count: i32,
    #[doc = " The index of the first visible semantic child of a scroll node."]
    pub scroll_index: i32,
    #[doc = " The current scrolling position in logical pixels if the node is\n scrollable."]
    pub scroll_position: f64,
    #[doc = " The maximum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_max: f64,
    #[doc = " The minimum in-range value for `scrollPosition` if the node is scrollable."]
    pub scroll_extent_min: f64,
    #[doc = " The elevation along the z-axis at which the rect of this semantics node is\n located above its parent."]
    pub elevation: f64,
    #[doc = " Describes how much space the semantics node takes up along the z-axis."]
    pub thickness: f64,
    #[doc = " A textual description of the node."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " A brief description of the result of performing an action on the node."]
    pub hint: *const ::std::os::raw::c_char,
    #[doc = " A textual description of the current value of the node."]
    pub value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionIncrease`\n action has been performed."]
    pub increased_value: *const ::std::os::raw::c_char,
    #[doc = " A value that `value` will have after a kFlutterSemanticsActionDecrease`\n action has been performed."]
    pub decreased_value: *const ::std::os::raw::c_char,
    #[doc = " The reading direction for `label`, `value`, `hint`, `increasedValue`,\n `decreasedValue`, and `tooltip`."]
    pub text_direction: FlutterTextDirection,
    #[doc = " The bounding box for this node in its coordinate system."]
    pub rect: FlutterRect,
    #[doc = " The transform from this node's coordinate system to its parent's\n coordinate system."]
    pub transform: FlutterTransformation,
    #[doc = " The number of children this node has."]
    pub child_count: usize,
    #[doc = " Array of child node IDs in traversal order. Has length `child_count`."]
    pub children_in_traversal_order: *const i32,
    #[doc = " Array of child node IDs in hit test order. Has length `child_count`."]
    pub children_in_hit_test_order: *const i32,
    #[doc = " The number of custom accessibility action associated with this node."]
    pub custom_accessibility_actions_count: usize,
    #[doc = " Array of `FlutterSemanticsCustomAction` IDs associated with this node.\n Has length `custom_accessibility_actions_count`."]
    pub custom_accessibility_actions: *const i32,
    #[doc = " Identifier of the platform view associated with this semantics node, or\n -1 if none."]
    pub platform_view_id: FlutterPlatformViewIdentifier,
    #[doc = " A textual tooltip attached to the node."]
    pub tooltip: *const ::std::os::raw::c_char,
    pub label_attribute_count: usize,
    pub label_attributes: *mut *const FlutterStringAttribute,
    pub hint_attribute_count: usize,
    pub hint_attributes: *mut *const FlutterStringAttribute,
    pub value_attribute_count: usize,
    pub value_attributes: *mut *const FlutterStringAttribute,
    pub increased_value_attribute_count: usize,
    pub increased_value_attributes: *mut *const FlutterStringAttribute,
    pub decreased_value_attribute_count: usize,
    pub decreased_value_attributes: *mut *const FlutterStringAttribute,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsNode2"][::std::mem::size_of::<FlutterSemanticsNode2>() - 368usize];
    ["Alignment of FlutterSemanticsNode2"]
        [::std::mem::align_of::<FlutterSemanticsNode2>() - 8usize];
    ["Offset of field: FlutterSemanticsNode2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsNode2::id"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, id) - 8usize];
    ["Offset of field: FlutterSemanticsNode2::flags"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, flags) - 12usize];
    ["Offset of field: FlutterSemanticsNode2::actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, actions) - 16usize];
    ["Offset of field: FlutterSemanticsNode2::text_selection_base"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_selection_base) - 20usize];
    ["Offset of field: FlutterSemanticsNode2::text_selection_extent"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_selection_extent) - 24usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_child_count) - 28usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_index"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_index) - 32usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_position"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_position) - 40usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_extent_max"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_extent_max) - 48usize];
    ["Offset of field: FlutterSemanticsNode2::scroll_extent_min"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, scroll_extent_min) - 56usize];
    ["Offset of field: FlutterSemanticsNode2::elevation"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, elevation) - 64usize];
    ["Offset of field: FlutterSemanticsNode2::thickness"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, thickness) - 72usize];
    ["Offset of field: FlutterSemanticsNode2::label"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label) - 80usize];
    ["Offset of field: FlutterSemanticsNode2::hint"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint) - 88usize];
    ["Offset of field: FlutterSemanticsNode2::value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value) - 96usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value) - 104usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value) - 112usize];
    ["Offset of field: FlutterSemanticsNode2::text_direction"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, text_direction) - 120usize];
    ["Offset of field: FlutterSemanticsNode2::rect"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, rect) - 128usize];
    ["Offset of field: FlutterSemanticsNode2::transform"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, transform) - 160usize];
    ["Offset of field: FlutterSemanticsNode2::child_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, child_count) - 232usize];
    ["Offset of field: FlutterSemanticsNode2::children_in_traversal_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, children_in_traversal_order) - 240usize];
    ["Offset of field: FlutterSemanticsNode2::children_in_hit_test_order"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, children_in_hit_test_order) - 248usize];
    ["Offset of field: FlutterSemanticsNode2::custom_accessibility_actions_count"][::std::mem::offset_of!(
        FlutterSemanticsNode2,
        custom_accessibility_actions_count
    ) - 256usize];
    ["Offset of field: FlutterSemanticsNode2::custom_accessibility_actions"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, custom_accessibility_actions) - 264usize];
    ["Offset of field: FlutterSemanticsNode2::platform_view_id"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, platform_view_id) - 272usize];
    ["Offset of field: FlutterSemanticsNode2::tooltip"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, tooltip) - 280usize];
    ["Offset of field: FlutterSemanticsNode2::label_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label_attribute_count) - 288usize];
    ["Offset of field: FlutterSemanticsNode2::label_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, label_attributes) - 296usize];
    ["Offset of field: FlutterSemanticsNode2::hint_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint_attribute_count) - 304usize];
    ["Offset of field: FlutterSemanticsNode2::hint_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, hint_attributes) - 312usize];
    ["Offset of field: FlutterSemanticsNode2::value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value_attribute_count) - 320usize];
    ["Offset of field: FlutterSemanticsNode2::value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, value_attributes) - 328usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value_attribute_count) - 336usize];
    ["Offset of field: FlutterSemanticsNode2::increased_value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, increased_value_attributes) - 344usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value_attribute_count"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value_attribute_count) - 352usize];
    ["Offset of field: FlutterSemanticsNode2::decreased_value_attributes"]
        [::std::mem::offset_of!(FlutterSemanticsNode2, decreased_value_attributes) - 360usize];
};
impl Default for FlutterSemanticsNode2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " `FlutterSemanticsCustomAction` ID used as a sentinel to signal the end of a\n batch of semantics custom action updates. This is unused if using\n `FlutterUpdateSemanticsCallback2`."]
    pub static kFlutterSemanticsCustomActionIdBatchEnd: i32;
}
#[doc = " A custom semantics action, or action override.\n\n Custom actions can be registered by applications in order to provide\n semantic actions other than the standard actions available through the\n `FlutterSemanticsAction` enum.\n\n Action overrides are custom actions that the application developer requests\n to be used in place of the standard actions in the `FlutterSemanticsAction`\n enum.\n\n @deprecated     Use `FlutterSemanticsCustomAction2` instead. In order to\n                 preserve ABI compatility for existing users, no new fields\n                 will be added to this struct. New fields will continue to\n                 be added to `FlutterSemanticsCustomAction2`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsCustomAction {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsCustomAction)."]
    pub struct_size: usize,
    #[doc = " The unique custom action or action override ID."]
    pub id: i32,
    #[doc = " For overridden standard actions, corresponds to the\n `FlutterSemanticsAction` to override."]
    pub override_action: FlutterSemanticsAction,
    #[doc = " The user-readable name of this custom semantics action."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " The hint description of this custom semantics action."]
    pub hint: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsCustomAction"]
        [::std::mem::size_of::<FlutterSemanticsCustomAction>() - 32usize];
    ["Alignment of FlutterSemanticsCustomAction"]
        [::std::mem::align_of::<FlutterSemanticsCustomAction>() - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsCustomAction::id"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, id) - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction::override_action"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, override_action) - 12usize];
    ["Offset of field: FlutterSemanticsCustomAction::label"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, label) - 16usize];
    ["Offset of field: FlutterSemanticsCustomAction::hint"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction, hint) - 24usize];
};
impl Default for FlutterSemanticsCustomAction {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A custom semantics action, or action override.\n\n Custom actions can be registered by applications in order to provide\n semantic actions other than the standard actions available through the\n `FlutterSemanticsAction` enum.\n\n Action overrides are custom actions that the application developer requests\n to be used in place of the standard actions in the `FlutterSemanticsAction`\n enum.\n\n @see\n https://api.flutter.dev/flutter/semantics/CustomSemanticsAction-class.html"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsCustomAction2 {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsCustomAction)."]
    pub struct_size: usize,
    #[doc = " The unique custom action or action override ID."]
    pub id: i32,
    #[doc = " For overridden standard actions, corresponds to the\n `FlutterSemanticsAction` to override."]
    pub override_action: FlutterSemanticsAction,
    #[doc = " The user-readable name of this custom semantics action."]
    pub label: *const ::std::os::raw::c_char,
    #[doc = " The hint description of this custom semantics action."]
    pub hint: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsCustomAction2"]
        [::std::mem::size_of::<FlutterSemanticsCustomAction2>() - 32usize];
    ["Alignment of FlutterSemanticsCustomAction2"]
        [::std::mem::align_of::<FlutterSemanticsCustomAction2>() - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsCustomAction2::id"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, id) - 8usize];
    ["Offset of field: FlutterSemanticsCustomAction2::override_action"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, override_action) - 12usize];
    ["Offset of field: FlutterSemanticsCustomAction2::label"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, label) - 16usize];
    ["Offset of field: FlutterSemanticsCustomAction2::hint"]
        [::std::mem::offset_of!(FlutterSemanticsCustomAction2, hint) - 24usize];
};
impl Default for FlutterSemanticsCustomAction2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A batch of updates to semantics nodes and custom actions.\n\n @deprecated     Use `FlutterSemanticsUpdate2` instead. Adding members\n                 to `FlutterSemanticsNode` or `FlutterSemanticsCustomAction`\n                 breaks the ABI of this struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsUpdate {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsUpdate)."]
    pub struct_size: usize,
    #[doc = " The number of semantics node updates."]
    pub nodes_count: usize,
    pub nodes: *mut FlutterSemanticsNode,
    #[doc = " The number of semantics custom action updates."]
    pub custom_actions_count: usize,
    #[doc = " Array of semantics custom actions. Has length `custom_actions_count`."]
    pub custom_actions: *mut FlutterSemanticsCustomAction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsUpdate"][::std::mem::size_of::<FlutterSemanticsUpdate>() - 40usize];
    ["Alignment of FlutterSemanticsUpdate"]
        [::std::mem::align_of::<FlutterSemanticsUpdate>() - 8usize];
    ["Offset of field: FlutterSemanticsUpdate::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsUpdate::nodes_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, nodes_count) - 8usize];
    ["Offset of field: FlutterSemanticsUpdate::nodes"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, nodes) - 16usize];
    ["Offset of field: FlutterSemanticsUpdate::custom_actions_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, custom_actions_count) - 24usize];
    ["Offset of field: FlutterSemanticsUpdate::custom_actions"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate, custom_actions) - 32usize];
};
impl Default for FlutterSemanticsUpdate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A batch of updates to semantics nodes and custom actions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSemanticsUpdate2 {
    #[doc = " The size of the struct. Must be sizeof(FlutterSemanticsUpdate2)."]
    pub struct_size: usize,
    #[doc = " The number of semantics node updates."]
    pub node_count: usize,
    pub nodes: *mut *mut FlutterSemanticsNode2,
    #[doc = " The number of semantics custom action updates."]
    pub custom_action_count: usize,
    #[doc = " Array of semantics custom action pointers. Has length\n `custom_action_count`."]
    pub custom_actions: *mut *mut FlutterSemanticsCustomAction2,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSemanticsUpdate2"][::std::mem::size_of::<FlutterSemanticsUpdate2>() - 40usize];
    ["Alignment of FlutterSemanticsUpdate2"]
        [::std::mem::align_of::<FlutterSemanticsUpdate2>() - 8usize];
    ["Offset of field: FlutterSemanticsUpdate2::struct_size"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, struct_size) - 0usize];
    ["Offset of field: FlutterSemanticsUpdate2::node_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, node_count) - 8usize];
    ["Offset of field: FlutterSemanticsUpdate2::nodes"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, nodes) - 16usize];
    ["Offset of field: FlutterSemanticsUpdate2::custom_action_count"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, custom_action_count) - 24usize];
    ["Offset of field: FlutterSemanticsUpdate2::custom_actions"]
        [::std::mem::offset_of!(FlutterSemanticsUpdate2, custom_actions) - 32usize];
};
impl Default for FlutterSemanticsUpdate2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterUpdateSemanticsNodeCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsNode, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterUpdateSemanticsCustomActionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const FlutterSemanticsCustomAction,
        arg2: *mut ::std::os::raw::c_void,
    ),
>;
pub type FlutterUpdateSemanticsCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsUpdate, arg2: *mut ::std::os::raw::c_void),
>;
pub type FlutterUpdateSemanticsCallback2 = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterSemanticsUpdate2, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " An update to whether a message channel has a listener set or not."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterChannelUpdate {
    #[doc = " The size of the struct. Must be sizeof(FlutterChannelUpdate)."]
    pub struct_size: usize,
    #[doc = " The name of the channel."]
    pub channel: *const ::std::os::raw::c_char,
    #[doc = " True if a listener has been set, false if one has been cleared."]
    pub listening: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterChannelUpdate"][::std::mem::size_of::<FlutterChannelUpdate>() - 24usize];
    ["Alignment of FlutterChannelUpdate"][::std::mem::align_of::<FlutterChannelUpdate>() - 8usize];
    ["Offset of field: FlutterChannelUpdate::struct_size"]
        [::std::mem::offset_of!(FlutterChannelUpdate, struct_size) - 0usize];
    ["Offset of field: FlutterChannelUpdate::channel"]
        [::std::mem::offset_of!(FlutterChannelUpdate, channel) - 8usize];
    ["Offset of field: FlutterChannelUpdate::listening"]
        [::std::mem::offset_of!(FlutterChannelUpdate, listening) - 16usize];
};
impl Default for FlutterChannelUpdate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterChannelUpdateCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const FlutterChannelUpdate, arg2: *mut ::std::os::raw::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterTaskRunner {
    _unused: [u8; 0],
}
pub type FlutterTaskRunner = *mut _FlutterTaskRunner;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterTask {
    pub runner: FlutterTaskRunner,
    pub task: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTask"][::std::mem::size_of::<FlutterTask>() - 16usize];
    ["Alignment of FlutterTask"][::std::mem::align_of::<FlutterTask>() - 8usize];
    ["Offset of field: FlutterTask::runner"][::std::mem::offset_of!(FlutterTask, runner) - 0usize];
    ["Offset of field: FlutterTask::task"][::std::mem::offset_of!(FlutterTask, task) - 8usize];
};
impl Default for FlutterTask {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterTaskRunnerPostTaskCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: FlutterTask, arg2: u64, arg3: *mut ::std::os::raw::c_void),
>;
#[doc = " An interface used by the Flutter engine to execute tasks at the target time\n on a specified thread. There should be a 1-1 relationship between a thread\n and a task runner. It is undefined behavior to run a task on a thread that\n is not associated with its task runner."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterTaskRunnerDescription {
    #[doc = " The size of this struct. Must be sizeof(FlutterTaskRunnerDescription)."]
    pub struct_size: usize,
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " May be called from any thread. Should return true if tasks posted on the\n calling thread will be run on that same thread.\n\n @attention     This field is required."]
    pub runs_task_on_current_thread_callback: BoolCallback,
    #[doc = " May be called from any thread. The given task should be executed by the\n embedder on the thread associated with that task runner by calling\n `FlutterEngineRunTask` at the given target time. The system monotonic\n clock should be used for the target time. The target time is the absolute\n time from epoch (NOT a delta) at which the task must be returned back to\n the engine on the correct thread. If the embedder needs to calculate a\n delta, `FlutterEngineGetCurrentTime` may be called and the difference used\n as the delta.\n\n @attention     This field is required."]
    pub post_task_callback: FlutterTaskRunnerPostTaskCallback,
    #[doc = " A unique identifier for the task runner. If multiple task runners service\n tasks on the same thread, their identifiers must match."]
    pub identifier: usize,
    #[doc = " The callback invoked when the task runner is destroyed."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterTaskRunnerDescription"]
        [::std::mem::size_of::<FlutterTaskRunnerDescription>() - 48usize];
    ["Alignment of FlutterTaskRunnerDescription"]
        [::std::mem::align_of::<FlutterTaskRunnerDescription>() - 8usize];
    ["Offset of field: FlutterTaskRunnerDescription::struct_size"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, struct_size) - 0usize];
    ["Offset of field: FlutterTaskRunnerDescription::user_data"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, user_data) - 8usize];
    ["Offset of field: FlutterTaskRunnerDescription::runs_task_on_current_thread_callback"][::std::mem::offset_of!(
        FlutterTaskRunnerDescription,
        runs_task_on_current_thread_callback
    )
        - 16usize];
    ["Offset of field: FlutterTaskRunnerDescription::post_task_callback"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, post_task_callback) - 24usize];
    ["Offset of field: FlutterTaskRunnerDescription::identifier"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, identifier) - 32usize];
    ["Offset of field: FlutterTaskRunnerDescription::destruction_callback"]
        [::std::mem::offset_of!(FlutterTaskRunnerDescription, destruction_callback) - 40usize];
};
impl Default for FlutterTaskRunnerDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterCustomTaskRunners {
    #[doc = " The size of this struct. Must be sizeof(FlutterCustomTaskRunners)."]
    pub struct_size: usize,
    #[doc = " Specify the task runner for the thread on which the `FlutterEngineRun`\n call is made. The same task runner description can be specified for both\n the render and platform task runners. This makes the Flutter engine use\n the same thread for both task runners."]
    pub platform_task_runner: *const FlutterTaskRunnerDescription,
    #[doc = " Specify the task runner for the thread on which the render tasks will be\n run. The same task runner description can be specified for both the render\n and platform task runners. This makes the Flutter engine use the same\n thread for both task runners."]
    pub render_task_runner: *const FlutterTaskRunnerDescription,
    #[doc = " Specify a callback that is used to set the thread priority for embedder\n task runners."]
    pub thread_priority_setter:
        ::std::option::Option<unsafe extern "C" fn(arg1: FlutterThreadPriority)>,
    #[doc = " Specify the task runner for the thread on which the UI tasks will be run.\n This may be same as platform_task_runner, in which case the Flutter engine\n will run the UI isolate on platform thread."]
    pub ui_task_runner: *const FlutterTaskRunnerDescription,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterCustomTaskRunners"]
        [::std::mem::size_of::<FlutterCustomTaskRunners>() - 40usize];
    ["Alignment of FlutterCustomTaskRunners"]
        [::std::mem::align_of::<FlutterCustomTaskRunners>() - 8usize];
    ["Offset of field: FlutterCustomTaskRunners::struct_size"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, struct_size) - 0usize];
    ["Offset of field: FlutterCustomTaskRunners::platform_task_runner"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, platform_task_runner) - 8usize];
    ["Offset of field: FlutterCustomTaskRunners::render_task_runner"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, render_task_runner) - 16usize];
    ["Offset of field: FlutterCustomTaskRunners::thread_priority_setter"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, thread_priority_setter) - 24usize];
    ["Offset of field: FlutterCustomTaskRunners::ui_task_runner"]
        [::std::mem::offset_of!(FlutterCustomTaskRunners, ui_task_runner) - 32usize];
};
impl Default for FlutterCustomTaskRunners {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterOpenGLBackingStore {
    #[doc = " The type of the OpenGL backing store. Currently, it can either be a\n texture or a framebuffer."]
    pub type_: FlutterOpenGLTargetType,
    pub __bindgen_anon_1: FlutterOpenGLBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterOpenGLBackingStore__bindgen_ty_1 {
    #[doc = " A texture for Flutter to render into."]
    pub texture: FlutterOpenGLTexture,
    #[doc = " A framebuffer for Flutter to render into. The embedder must ensure that\n the framebuffer is complete."]
    pub framebuffer: FlutterOpenGLFramebuffer,
    #[doc = " A surface for Flutter to render into. Basically a wrapper around\n a closure that'll be called when the surface should be made current."]
    pub surface: FlutterOpenGLSurface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterOpenGLBackingStore__bindgen_ty_1>() - 48usize];
    ["Alignment of FlutterOpenGLBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterOpenGLBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::texture"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, texture) - 0usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::framebuffer"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, framebuffer) - 0usize];
    ["Offset of field: FlutterOpenGLBackingStore__bindgen_ty_1::surface"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore__bindgen_ty_1, surface) - 0usize];
};
impl Default for FlutterOpenGLBackingStore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterOpenGLBackingStore"]
        [::std::mem::size_of::<FlutterOpenGLBackingStore>() - 56usize];
    ["Alignment of FlutterOpenGLBackingStore"]
        [::std::mem::align_of::<FlutterOpenGLBackingStore>() - 8usize];
    ["Offset of field: FlutterOpenGLBackingStore::type_"]
        [::std::mem::offset_of!(FlutterOpenGLBackingStore, type_) - 0usize];
};
impl Default for FlutterOpenGLBackingStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSoftwareBackingStore {
    #[doc = " A pointer to the raw bytes of the allocation described by this software\n backing store."]
    pub allocation: *const ::std::os::raw::c_void,
    #[doc = " The number of bytes in a single row of the allocation."]
    pub row_bytes: usize,
    #[doc = " The number of rows in the allocation."]
    pub height: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareBackingStore"]
        [::std::mem::size_of::<FlutterSoftwareBackingStore>() - 40usize];
    ["Alignment of FlutterSoftwareBackingStore"]
        [::std::mem::align_of::<FlutterSoftwareBackingStore>() - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore::allocation"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, allocation) - 0usize];
    ["Offset of field: FlutterSoftwareBackingStore::row_bytes"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, row_bytes) - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore::height"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, height) - 16usize];
    ["Offset of field: FlutterSoftwareBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, user_data) - 24usize];
    ["Offset of field: FlutterSoftwareBackingStore::destruction_callback"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore, destruction_callback) - 32usize];
};
impl Default for FlutterSoftwareBackingStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterSoftwareBackingStore2 {
    #[doc = " The size of this struct. Must be sizeof(FlutterSoftwareBackingStore2)."]
    pub struct_size: usize,
    #[doc = " A pointer to the raw bytes of the allocation described by this software\n backing store."]
    pub allocation: *const ::std::os::raw::c_void,
    #[doc = " The number of bytes in a single row of the allocation."]
    pub row_bytes: usize,
    #[doc = " The number of rows in the allocation."]
    pub height: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
    #[doc = " The pixel format that the engine should use to render into the allocation.\n\n On Linux, kFlutterSoftwarePixelFormatBGRA8888 is most commonly used."]
    pub pixel_format: FlutterSoftwarePixelFormat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterSoftwareBackingStore2"]
        [::std::mem::size_of::<FlutterSoftwareBackingStore2>() - 56usize];
    ["Alignment of FlutterSoftwareBackingStore2"]
        [::std::mem::align_of::<FlutterSoftwareBackingStore2>() - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore2::struct_size"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, struct_size) - 0usize];
    ["Offset of field: FlutterSoftwareBackingStore2::allocation"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, allocation) - 8usize];
    ["Offset of field: FlutterSoftwareBackingStore2::row_bytes"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, row_bytes) - 16usize];
    ["Offset of field: FlutterSoftwareBackingStore2::height"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, height) - 24usize];
    ["Offset of field: FlutterSoftwareBackingStore2::user_data"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, user_data) - 32usize];
    ["Offset of field: FlutterSoftwareBackingStore2::destruction_callback"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, destruction_callback) - 40usize];
    ["Offset of field: FlutterSoftwareBackingStore2::pixel_format"]
        [::std::mem::offset_of!(FlutterSoftwareBackingStore2, pixel_format) - 48usize];
};
impl Default for FlutterSoftwareBackingStore2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterMetalBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterMetalBackingStore)."]
    pub struct_size: usize,
    pub __bindgen_anon_1: FlutterMetalBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterMetalBackingStore__bindgen_ty_1 {
    pub texture: FlutterMetalTexture,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterMetalBackingStore__bindgen_ty_1>() - 40usize];
    ["Alignment of FlutterMetalBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterMetalBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterMetalBackingStore__bindgen_ty_1::texture"]
        [::std::mem::offset_of!(FlutterMetalBackingStore__bindgen_ty_1, texture) - 0usize];
};
impl Default for FlutterMetalBackingStore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterMetalBackingStore"]
        [::std::mem::size_of::<FlutterMetalBackingStore>() - 48usize];
    ["Alignment of FlutterMetalBackingStore"]
        [::std::mem::align_of::<FlutterMetalBackingStore>() - 8usize];
    ["Offset of field: FlutterMetalBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterMetalBackingStore, struct_size) - 0usize];
};
impl Default for FlutterMetalBackingStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterVulkanBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterVulkanBackingStore)."]
    pub struct_size: usize,
    #[doc = " The image that the layer will be rendered to. This image must already be\n available for the engine to bind for writing when it's given to the engine\n via the backing store creation callback. The engine will perform a host\n sync for all layers prior to calling the compositor present callback, and\n so the written layer images can be freely bound by the embedder without\n any additional synchronization."]
    pub image: *const FlutterVulkanImage,
    #[doc = " A baton that is not interpreted by the engine in any way. It will be given\n back to the embedder in the destruction callback below. Embedder resources\n may be associated with this baton."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " The callback invoked by the engine when it no longer needs this backing\n store."]
    pub destruction_callback: VoidCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterVulkanBackingStore"]
        [::std::mem::size_of::<FlutterVulkanBackingStore>() - 32usize];
    ["Alignment of FlutterVulkanBackingStore"]
        [::std::mem::align_of::<FlutterVulkanBackingStore>() - 8usize];
    ["Offset of field: FlutterVulkanBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, struct_size) - 0usize];
    ["Offset of field: FlutterVulkanBackingStore::image"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, image) - 8usize];
    ["Offset of field: FlutterVulkanBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, user_data) - 16usize];
    ["Offset of field: FlutterVulkanBackingStore::destruction_callback"]
        [::std::mem::offset_of!(FlutterVulkanBackingStore, destruction_callback) - 24usize];
};
impl Default for FlutterVulkanBackingStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Indicates that the Flutter application requested that an opacity be\n applied to the platform view."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeOpacity:
    FlutterPlatformViewMutationType = 0;
#[doc = " Indicates that the Flutter application requested that the platform view be\n clipped using a rectangle."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeClipRect:
    FlutterPlatformViewMutationType = 1;
#[doc = " Indicates that the Flutter application requested that the platform view be\n clipped using a rounded rectangle."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeClipRoundedRect:
    FlutterPlatformViewMutationType = 2;
#[doc = " Indicates that the Flutter application requested that the platform view be\n transformed before composition."]
pub const FlutterPlatformViewMutationType_kFlutterPlatformViewMutationTypeTransformation:
    FlutterPlatformViewMutationType = 3;
pub type FlutterPlatformViewMutationType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterPlatformViewMutation {
    #[doc = " The type of the mutation described by the subsequent union."]
    pub type_: FlutterPlatformViewMutationType,
    pub __bindgen_anon_1: FlutterPlatformViewMutation__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterPlatformViewMutation__bindgen_ty_1 {
    pub opacity: f64,
    pub clip_rect: FlutterRect,
    pub clip_rounded_rect: FlutterRoundedRect,
    pub transformation: FlutterTransformation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformViewMutation__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterPlatformViewMutation__bindgen_ty_1>() - 96usize];
    ["Alignment of FlutterPlatformViewMutation__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterPlatformViewMutation__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::opacity"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation__bindgen_ty_1, opacity) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::clip_rect"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation__bindgen_ty_1, clip_rect) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::clip_rounded_rect"][::std::mem::offset_of!(
        FlutterPlatformViewMutation__bindgen_ty_1,
        clip_rounded_rect
    ) - 0usize];
    ["Offset of field: FlutterPlatformViewMutation__bindgen_ty_1::transformation"][::std::mem::offset_of!(
        FlutterPlatformViewMutation__bindgen_ty_1,
        transformation
    ) - 0usize];
};
impl Default for FlutterPlatformViewMutation__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformViewMutation"]
        [::std::mem::size_of::<FlutterPlatformViewMutation>() - 104usize];
    ["Alignment of FlutterPlatformViewMutation"]
        [::std::mem::align_of::<FlutterPlatformViewMutation>() - 8usize];
    ["Offset of field: FlutterPlatformViewMutation::type_"]
        [::std::mem::offset_of!(FlutterPlatformViewMutation, type_) - 0usize];
};
impl Default for FlutterPlatformViewMutation {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPlatformView {
    #[doc = " The size of this struct. Must be sizeof(FlutterPlatformView)."]
    pub struct_size: usize,
    #[doc = " The identifier of this platform view. This identifier is specified by the\n application when a platform view is added to the scene via the\n `SceneBuilder.addPlatformView` call."]
    pub identifier: FlutterPlatformViewIdentifier,
    #[doc = " The number of mutations to be applied to the platform view by the embedder\n before on-screen composition."]
    pub mutations_count: usize,
    #[doc = " The mutations to be applied by this platform view before it is composited\n on-screen. The Flutter application may transform the platform view but\n these transformations cannot be affected by the Flutter compositor because\n it does not render platform views. Since the embedder is responsible for\n composition of these views, it is also the embedder's responsibility to\n affect the appropriate transformation.\n\n The mutations must be applied in order. The mutations done in the\n collection don't take into account the device pixel ratio or the root\n surface transformation. If these exist, the first mutation in the list\n will be a transformation mutation to make sure subsequent mutations are in\n the correct coordinate space."]
    pub mutations: *mut *const FlutterPlatformViewMutation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPlatformView"][::std::mem::size_of::<FlutterPlatformView>() - 32usize];
    ["Alignment of FlutterPlatformView"][::std::mem::align_of::<FlutterPlatformView>() - 8usize];
    ["Offset of field: FlutterPlatformView::struct_size"]
        [::std::mem::offset_of!(FlutterPlatformView, struct_size) - 0usize];
    ["Offset of field: FlutterPlatformView::identifier"]
        [::std::mem::offset_of!(FlutterPlatformView, identifier) - 8usize];
    ["Offset of field: FlutterPlatformView::mutations_count"]
        [::std::mem::offset_of!(FlutterPlatformView, mutations_count) - 16usize];
    ["Offset of field: FlutterPlatformView::mutations"]
        [::std::mem::offset_of!(FlutterPlatformView, mutations) - 24usize];
};
impl Default for FlutterPlatformView {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Specifies an OpenGL backing store. Can either be an OpenGL texture or\n framebuffer."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeOpenGL: FlutterBackingStoreType = 0;
#[doc = " Specified an software allocation for Flutter to render into using the CPU."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeSoftware: FlutterBackingStoreType = 1;
#[doc = " Specifies a Metal backing store. This is backed by a Metal texture."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeMetal: FlutterBackingStoreType = 2;
#[doc = " Specifies a Vulkan backing store. This is backed by a Vulkan VkImage."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeVulkan: FlutterBackingStoreType = 3;
#[doc = " Specifies a allocation that the engine should render into using\n software rendering."]
pub const FlutterBackingStoreType_kFlutterBackingStoreTypeSoftware2: FlutterBackingStoreType = 4;
pub type FlutterBackingStoreType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterBackingStore {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStore)."]
    pub struct_size: usize,
    #[doc = " A baton that is not interpreted by the engine in any way. The embedder may\n use this to associate resources that are tied to the lifecycle of the\n `FlutterBackingStore`."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " Specifies the type of backing store."]
    pub type_: FlutterBackingStoreType,
    #[doc = " Indicates if this backing store was updated since the last time it was\n associated with a presented layer."]
    pub did_update: bool,
    pub __bindgen_anon_1: FlutterBackingStore__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterBackingStore__bindgen_ty_1 {
    #[doc = " The description of the OpenGL backing store."]
    pub open_gl: FlutterOpenGLBackingStore,
    #[doc = " The description of the software backing store."]
    pub software: FlutterSoftwareBackingStore,
    #[doc = " The description of the software backing store."]
    pub software2: FlutterSoftwareBackingStore2,
    pub metal: FlutterMetalBackingStore,
    pub vulkan: FlutterVulkanBackingStore,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStore__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterBackingStore__bindgen_ty_1>() - 56usize];
    ["Alignment of FlutterBackingStore__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterBackingStore__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::open_gl"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, open_gl) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::software"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, software) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::software2"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, software2) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::metal"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, metal) - 0usize];
    ["Offset of field: FlutterBackingStore__bindgen_ty_1::vulkan"]
        [::std::mem::offset_of!(FlutterBackingStore__bindgen_ty_1, vulkan) - 0usize];
};
impl Default for FlutterBackingStore__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStore"][::std::mem::size_of::<FlutterBackingStore>() - 80usize];
    ["Alignment of FlutterBackingStore"][::std::mem::align_of::<FlutterBackingStore>() - 8usize];
    ["Offset of field: FlutterBackingStore::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStore, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStore::user_data"]
        [::std::mem::offset_of!(FlutterBackingStore, user_data) - 8usize];
    ["Offset of field: FlutterBackingStore::type_"]
        [::std::mem::offset_of!(FlutterBackingStore, type_) - 16usize];
    ["Offset of field: FlutterBackingStore::did_update"]
        [::std::mem::offset_of!(FlutterBackingStore, did_update) - 20usize];
};
impl Default for FlutterBackingStore {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterBackingStoreConfig {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStoreConfig)."]
    pub struct_size: usize,
    #[doc = " The size of the render target the engine expects to render into."]
    pub size: FlutterSize,
    #[doc = " The identifier for the view that the engine will use this backing store to\n render into."]
    pub view_id: FlutterViewId,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStoreConfig"]
        [::std::mem::size_of::<FlutterBackingStoreConfig>() - 32usize];
    ["Alignment of FlutterBackingStoreConfig"]
        [::std::mem::align_of::<FlutterBackingStoreConfig>() - 8usize];
    ["Offset of field: FlutterBackingStoreConfig::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStoreConfig::size"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, size) - 8usize];
    ["Offset of field: FlutterBackingStoreConfig::view_id"]
        [::std::mem::offset_of!(FlutterBackingStoreConfig, view_id) - 24usize];
};
#[doc = " Indicates that the contents of this layer are rendered by Flutter into a\n backing store."]
pub const FlutterLayerContentType_kFlutterLayerContentTypeBackingStore: FlutterLayerContentType = 0;
#[doc = " Indicates that the contents of this layer are determined by the embedder."]
pub const FlutterLayerContentType_kFlutterLayerContentTypePlatformView: FlutterLayerContentType = 1;
pub type FlutterLayerContentType = ::std::os::raw::c_int;
#[doc = " A region represented by a collection of non-overlapping rectangles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterRegion {
    #[doc = " The size of this struct. Must be sizeof(FlutterRegion)."]
    pub struct_size: usize,
    #[doc = " Number of rectangles in the region."]
    pub rects_count: usize,
    #[doc = " The rectangles that make up the region."]
    pub rects: *mut FlutterRect,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterRegion"][::std::mem::size_of::<FlutterRegion>() - 24usize];
    ["Alignment of FlutterRegion"][::std::mem::align_of::<FlutterRegion>() - 8usize];
    ["Offset of field: FlutterRegion::struct_size"]
        [::std::mem::offset_of!(FlutterRegion, struct_size) - 0usize];
    ["Offset of field: FlutterRegion::rects_count"]
        [::std::mem::offset_of!(FlutterRegion, rects_count) - 8usize];
    ["Offset of field: FlutterRegion::rects"]
        [::std::mem::offset_of!(FlutterRegion, rects) - 16usize];
};
impl Default for FlutterRegion {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Contains additional information about the backing store provided\n during presentation to the embedder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterBackingStorePresentInfo {
    #[doc = " The size of this struct. Must be sizeof(FlutterBackingStorePresentInfo)."]
    pub struct_size: usize,
    #[doc = " The area of the backing store that contains Flutter contents. Pixels\n outside of this area are transparent and the embedder may choose not\n to render them. Coordinates are in physical pixels."]
    pub paint_region: *mut FlutterRegion,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterBackingStorePresentInfo"]
        [::std::mem::size_of::<FlutterBackingStorePresentInfo>() - 16usize];
    ["Alignment of FlutterBackingStorePresentInfo"]
        [::std::mem::align_of::<FlutterBackingStorePresentInfo>() - 8usize];
    ["Offset of field: FlutterBackingStorePresentInfo::struct_size"]
        [::std::mem::offset_of!(FlutterBackingStorePresentInfo, struct_size) - 0usize];
    ["Offset of field: FlutterBackingStorePresentInfo::paint_region"]
        [::std::mem::offset_of!(FlutterBackingStorePresentInfo, paint_region) - 8usize];
};
impl Default for FlutterBackingStorePresentInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterLayer {
    #[doc = " This size of this struct. Must be sizeof(FlutterLayer)."]
    pub struct_size: usize,
    #[doc = " Each layer displays contents in one way or another. The type indicates\n whether those contents are specified by Flutter or the embedder."]
    pub type_: FlutterLayerContentType,
    pub __bindgen_anon_1: FlutterLayer__bindgen_ty_1,
    #[doc = " The offset of this layer (in physical pixels) relative to the top left of\n the root surface used by the engine."]
    pub offset: FlutterPoint,
    #[doc = " The size of the layer (in physical pixels)."]
    pub size: FlutterSize,
    #[doc = " Extra information for the backing store that the embedder may\n use during presentation."]
    pub backing_store_present_info: *mut FlutterBackingStorePresentInfo,
    pub presentation_time: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterLayer__bindgen_ty_1 {
    #[doc = " Indicates that the contents of this layer are rendered by Flutter into a\n backing store."]
    pub backing_store: *const FlutterBackingStore,
    #[doc = " Indicates that the contents of this layer are determined by the\n embedder."]
    pub platform_view: *const FlutterPlatformView,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLayer__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterLayer__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterLayer__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterLayer__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterLayer__bindgen_ty_1::backing_store"]
        [::std::mem::offset_of!(FlutterLayer__bindgen_ty_1, backing_store) - 0usize];
    ["Offset of field: FlutterLayer__bindgen_ty_1::platform_view"]
        [::std::mem::offset_of!(FlutterLayer__bindgen_ty_1, platform_view) - 0usize];
};
impl Default for FlutterLayer__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLayer"][::std::mem::size_of::<FlutterLayer>() - 72usize];
    ["Alignment of FlutterLayer"][::std::mem::align_of::<FlutterLayer>() - 8usize];
    ["Offset of field: FlutterLayer::struct_size"]
        [::std::mem::offset_of!(FlutterLayer, struct_size) - 0usize];
    ["Offset of field: FlutterLayer::type_"][::std::mem::offset_of!(FlutterLayer, type_) - 8usize];
    ["Offset of field: FlutterLayer::offset"]
        [::std::mem::offset_of!(FlutterLayer, offset) - 24usize];
    ["Offset of field: FlutterLayer::size"][::std::mem::offset_of!(FlutterLayer, size) - 40usize];
    ["Offset of field: FlutterLayer::backing_store_present_info"]
        [::std::mem::offset_of!(FlutterLayer, backing_store_present_info) - 56usize];
    ["Offset of field: FlutterLayer::presentation_time"]
        [::std::mem::offset_of!(FlutterLayer, presentation_time) - 64usize];
};
impl Default for FlutterLayer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterPresentViewInfo {
    #[doc = " The size of this struct.\n Must be sizeof(FlutterPresentViewInfo)."]
    pub struct_size: usize,
    #[doc = " The identifier of the target view."]
    pub view_id: FlutterViewId,
    #[doc = " The layers that should be composited onto the view."]
    pub layers: *mut *const FlutterLayer,
    #[doc = " The count of layers."]
    pub layers_count: usize,
    #[doc = " The |FlutterCompositor.user_data|."]
    pub user_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterPresentViewInfo"][::std::mem::size_of::<FlutterPresentViewInfo>() - 40usize];
    ["Alignment of FlutterPresentViewInfo"]
        [::std::mem::align_of::<FlutterPresentViewInfo>() - 8usize];
    ["Offset of field: FlutterPresentViewInfo::struct_size"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, struct_size) - 0usize];
    ["Offset of field: FlutterPresentViewInfo::view_id"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, view_id) - 8usize];
    ["Offset of field: FlutterPresentViewInfo::layers"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, layers) - 16usize];
    ["Offset of field: FlutterPresentViewInfo::layers_count"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, layers_count) - 24usize];
    ["Offset of field: FlutterPresentViewInfo::user_data"]
        [::std::mem::offset_of!(FlutterPresentViewInfo, user_data) - 32usize];
};
impl Default for FlutterPresentViewInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterBackingStoreCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        config: *const FlutterBackingStoreConfig,
        backing_store_out: *mut FlutterBackingStore,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type FlutterBackingStoreCollectCallback = ::std::option::Option<
    unsafe extern "C" fn(
        renderer: *const FlutterBackingStore,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type FlutterLayersPresentCallback = ::std::option::Option<
    unsafe extern "C" fn(
        layers: *mut *const FlutterLayer,
        layers_count: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " The callback invoked when the embedder should present to a view.\n\n The |FlutterPresentViewInfo| will be deallocated once the callback returns."]
pub type FlutterPresentViewCallback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const FlutterPresentViewInfo) -> bool>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterCompositor {
    #[doc = " This size of this struct. Must be sizeof(FlutterCompositor)."]
    pub struct_size: usize,
    #[doc = " A baton that in not interpreted by the engine in any way. If it passed\n back to the embedder in `FlutterCompositor.create_backing_store_callback`,\n `FlutterCompositor.collect_backing_store_callback`,\n `FlutterCompositor.present_layers_callback`, and\n `FlutterCompositor.present_view_callback`."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " A callback invoked by the engine to obtain a backing store for a specific\n `FlutterLayer`.\n\n On ABI stability: Callers must take care to restrict access within\n `FlutterBackingStore::struct_size` when specifying a new backing store to\n the engine. This only matters if the embedder expects to be used with\n engines older than the version whose headers it used during compilation.\n\n The callback should return true if the operation was successful."]
    pub create_backing_store_callback: FlutterBackingStoreCreateCallback,
    #[doc = " A callback invoked by the engine to release the backing store. The\n embedder may collect any resources associated with the backing store.\n\n The callback should return true if the operation was successful."]
    pub collect_backing_store_callback: FlutterBackingStoreCollectCallback,
    #[doc = " Callback invoked by the engine to composite the contents of each layer\n onto the implicit view.\n\n DEPRECATED: Use `present_view_callback` to support multiple views.\n If this callback is provided, `FlutterEngineAddView` and\n `FlutterEngineRemoveView` should not be used.\n\n Only one of `present_layers_callback` and `present_view_callback` may be\n provided. Providing both is an error and engine initialization will\n terminate.\n\n The callback should return true if the operation was successful."]
    pub present_layers_callback: FlutterLayersPresentCallback,
    #[doc = " Avoid caching backing stores provided by this compositor.\n\n The engine has an internal backing store cache. Instead of\n creating & destroying backing stores for every frame, created\n backing stores are automatically reused for subsequent frames.\n\n If you wish to change this behavior and destroy backing stores after\n they've been used once, and create new backing stores for every frame,\n you can set this bool to true."]
    pub avoid_backing_store_cache: bool,
    #[doc = " Callback invoked by the engine to composite the contents of each layer\n onto the specified view.\n\n Only one of `present_layers_callback` and `present_view_callback` may be\n provided. Providing both is an error and engine initialization will\n terminate.\n\n The callback should return true if the operation was successful."]
    pub present_view_callback: FlutterPresentViewCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterCompositor"][::std::mem::size_of::<FlutterCompositor>() - 56usize];
    ["Alignment of FlutterCompositor"][::std::mem::align_of::<FlutterCompositor>() - 8usize];
    ["Offset of field: FlutterCompositor::struct_size"]
        [::std::mem::offset_of!(FlutterCompositor, struct_size) - 0usize];
    ["Offset of field: FlutterCompositor::user_data"]
        [::std::mem::offset_of!(FlutterCompositor, user_data) - 8usize];
    ["Offset of field: FlutterCompositor::create_backing_store_callback"]
        [::std::mem::offset_of!(FlutterCompositor, create_backing_store_callback) - 16usize];
    ["Offset of field: FlutterCompositor::collect_backing_store_callback"]
        [::std::mem::offset_of!(FlutterCompositor, collect_backing_store_callback) - 24usize];
    ["Offset of field: FlutterCompositor::present_layers_callback"]
        [::std::mem::offset_of!(FlutterCompositor, present_layers_callback) - 32usize];
    ["Offset of field: FlutterCompositor::avoid_backing_store_cache"]
        [::std::mem::offset_of!(FlutterCompositor, avoid_backing_store_cache) - 40usize];
    ["Offset of field: FlutterCompositor::present_view_callback"]
        [::std::mem::offset_of!(FlutterCompositor, present_view_callback) - 48usize];
};
impl Default for FlutterCompositor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterLocale {
    #[doc = " This size of this struct. Must be sizeof(FlutterLocale)."]
    pub struct_size: usize,
    #[doc = " The language code of the locale. For example, \"en\". This is a required\n field. The string must be null terminated. It may be collected after the\n call to `FlutterEngineUpdateLocales`."]
    pub language_code: *const ::std::os::raw::c_char,
    #[doc = " The country code of the locale. For example, \"US\". This is a an optional\n field. The string must be null terminated if present. It may be collected\n after the call to `FlutterEngineUpdateLocales`. If not present, a\n `nullptr` may be specified."]
    pub country_code: *const ::std::os::raw::c_char,
    #[doc = " The script code of the locale. This is a an optional field. The string\n must be null terminated if present. It may be collected after the call to\n `FlutterEngineUpdateLocales`. If not present, a `nullptr` may be\n specified."]
    pub script_code: *const ::std::os::raw::c_char,
    #[doc = " The variant code of the locale. This is a an optional field. The string\n must be null terminated if present. It may be collected after the call to\n `FlutterEngineUpdateLocales`. If not present, a `nullptr` may be\n specified."]
    pub variant_code: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterLocale"][::std::mem::size_of::<FlutterLocale>() - 40usize];
    ["Alignment of FlutterLocale"][::std::mem::align_of::<FlutterLocale>() - 8usize];
    ["Offset of field: FlutterLocale::struct_size"]
        [::std::mem::offset_of!(FlutterLocale, struct_size) - 0usize];
    ["Offset of field: FlutterLocale::language_code"]
        [::std::mem::offset_of!(FlutterLocale, language_code) - 8usize];
    ["Offset of field: FlutterLocale::country_code"]
        [::std::mem::offset_of!(FlutterLocale, country_code) - 16usize];
    ["Offset of field: FlutterLocale::script_code"]
        [::std::mem::offset_of!(FlutterLocale, script_code) - 24usize];
    ["Offset of field: FlutterLocale::variant_code"]
        [::std::mem::offset_of!(FlutterLocale, variant_code) - 32usize];
};
impl Default for FlutterLocale {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Callback that returns the system locale.\n\n Embedders that implement this callback should return the `FlutterLocale`\n from the `supported_locales` list that most closely matches the\n user/device's preferred locale.\n\n This callback does not currently provide the user_data baton.\n https://github.com/flutter/flutter/issues/79826"]
pub type FlutterComputePlatformResolvedLocaleCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut *const FlutterLocale, arg2: usize) -> *const FlutterLocale,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterEngineDisplay {
    #[doc = " The size of this struct. Must be sizeof(FlutterEngineDisplay)."]
    pub struct_size: usize,
    pub display_id: FlutterEngineDisplayId,
    #[doc = " This is set to true if the embedder only has one display. In cases where\n this is set to true, the value of display_id is ignored. In cases where\n this is not set to true, it is expected that a valid display_id be\n provided."]
    pub single_display: bool,
    #[doc = " This represents the refresh period in frames per second. This value may be\n zero if the device is not running or unavailable or unknown."]
    pub refresh_rate: f64,
    #[doc = " The width of the display, in physical pixels."]
    pub width: usize,
    #[doc = " The height of the display, in physical pixels."]
    pub height: usize,
    #[doc = " The pixel ratio of the display, which is used to convert physical pixels\n to logical pixels."]
    pub device_pixel_ratio: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineDisplay"][::std::mem::size_of::<FlutterEngineDisplay>() - 56usize];
    ["Alignment of FlutterEngineDisplay"][::std::mem::align_of::<FlutterEngineDisplay>() - 8usize];
    ["Offset of field: FlutterEngineDisplay::struct_size"]
        [::std::mem::offset_of!(FlutterEngineDisplay, struct_size) - 0usize];
    ["Offset of field: FlutterEngineDisplay::display_id"]
        [::std::mem::offset_of!(FlutterEngineDisplay, display_id) - 8usize];
    ["Offset of field: FlutterEngineDisplay::single_display"]
        [::std::mem::offset_of!(FlutterEngineDisplay, single_display) - 16usize];
    ["Offset of field: FlutterEngineDisplay::refresh_rate"]
        [::std::mem::offset_of!(FlutterEngineDisplay, refresh_rate) - 24usize];
    ["Offset of field: FlutterEngineDisplay::width"]
        [::std::mem::offset_of!(FlutterEngineDisplay, width) - 32usize];
    ["Offset of field: FlutterEngineDisplay::height"]
        [::std::mem::offset_of!(FlutterEngineDisplay, height) - 40usize];
    ["Offset of field: FlutterEngineDisplay::device_pixel_ratio"]
        [::std::mem::offset_of!(FlutterEngineDisplay, device_pixel_ratio) - 48usize];
};
#[doc = " `FlutterEngineDisplay`s that were active during start-up. A display is\n considered active if:\n    1. The frame buffer hardware is connected.\n    2. The display is drawable, e.g. it isn't being mirrored from another\n    connected display or sleeping."]
pub const FlutterEngineDisplaysUpdateType_kFlutterEngineDisplaysUpdateTypeStartup:
    FlutterEngineDisplaysUpdateType = 0;
#[doc = " `FlutterEngineDisplay`s that were active during start-up. A display is\n considered active if:\n    1. The frame buffer hardware is connected.\n    2. The display is drawable, e.g. it isn't being mirrored from another\n    connected display or sleeping."]
pub const FlutterEngineDisplaysUpdateType_kFlutterEngineDisplaysUpdateTypeCount:
    FlutterEngineDisplaysUpdateType = 1;
#[doc = " The update type parameter that is passed to\n `FlutterEngineNotifyDisplayUpdate`."]
pub type FlutterEngineDisplaysUpdateType = ::std::os::raw::c_int;
pub type FlutterEngineDartPort = i64;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeNull:
    FlutterEngineDartObjectType = 0;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeBool:
    FlutterEngineDartObjectType = 1;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeInt32:
    FlutterEngineDartObjectType = 2;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeInt64:
    FlutterEngineDartObjectType = 3;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeDouble:
    FlutterEngineDartObjectType = 4;
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeString:
    FlutterEngineDartObjectType = 5;
#[doc = " The object will be made available to Dart code as an instance of\n Uint8List."]
pub const FlutterEngineDartObjectType_kFlutterEngineDartObjectTypeBuffer:
    FlutterEngineDartObjectType = 6;
pub type FlutterEngineDartObjectType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterEngineDartBuffer {
    #[doc = " The size of this struct. Must be sizeof(FlutterEngineDartBuffer)."]
    pub struct_size: usize,
    #[doc = " An opaque baton passed back to the embedder when the\n buffer_collect_callback is invoked. The engine does not interpret this\n field in any way."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " This is an optional field.\n\n When specified, the engine will assume that the buffer is owned by the\n embedder. When the data is no longer needed by any isolate, this callback\n will be made on an internal engine managed thread. The embedder is free to\n collect the buffer here. When this field is specified, it is the embedders\n responsibility to keep the buffer alive and not modify it till this\n callback is invoked by the engine. The user data specified in the callback\n is the value of `user_data` field in this struct.\n\n When NOT specified, the VM creates an internal copy of the buffer. The\n caller is free to modify the buffer as necessary or collect it immediately\n after the call to `FlutterEnginePostDartObject`.\n\n @attention      The buffer_collect_callback is will only be invoked by the\n                 engine when the `FlutterEnginePostDartObject` method\n                 returns kSuccess. In case of non-successful calls to this\n                 method, it is the embedders responsibility to collect the\n                 buffer."]
    pub buffer_collect_callback: VoidCallback,
    #[doc = " A pointer to the bytes of the buffer. When the buffer is owned by the\n embedder (by specifying the `buffer_collect_callback`), Dart code may\n modify that embedder owned buffer. For this reason, it is important that\n this buffer not have page protections that restrict writing to this\n buffer."]
    pub buffer: *mut u8,
    #[doc = " The size of the buffer."]
    pub buffer_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineDartBuffer"][::std::mem::size_of::<FlutterEngineDartBuffer>() - 40usize];
    ["Alignment of FlutterEngineDartBuffer"]
        [::std::mem::align_of::<FlutterEngineDartBuffer>() - 8usize];
    ["Offset of field: FlutterEngineDartBuffer::struct_size"]
        [::std::mem::offset_of!(FlutterEngineDartBuffer, struct_size) - 0usize];
    ["Offset of field: FlutterEngineDartBuffer::user_data"]
        [::std::mem::offset_of!(FlutterEngineDartBuffer, user_data) - 8usize];
    ["Offset of field: FlutterEngineDartBuffer::buffer_collect_callback"]
        [::std::mem::offset_of!(FlutterEngineDartBuffer, buffer_collect_callback) - 16usize];
    ["Offset of field: FlutterEngineDartBuffer::buffer"]
        [::std::mem::offset_of!(FlutterEngineDartBuffer, buffer) - 24usize];
    ["Offset of field: FlutterEngineDartBuffer::buffer_size"]
        [::std::mem::offset_of!(FlutterEngineDartBuffer, buffer_size) - 32usize];
};
impl Default for FlutterEngineDartBuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " This struct specifies the native representation of a Dart object that can be\n sent via a send port to any isolate in the VM that has the corresponding\n receive port.\n\n All fields in this struct are copied out in the call to\n `FlutterEnginePostDartObject` and the caller is free to reuse or collect\n this struct after that call."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterEngineDartObject {
    pub type_: FlutterEngineDartObjectType,
    pub __bindgen_anon_1: FlutterEngineDartObject__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterEngineDartObject__bindgen_ty_1 {
    pub bool_value: bool,
    pub int32_value: i32,
    pub int64_value: i64,
    pub double_value: f64,
    #[doc = " A null terminated string. This string will be copied by the VM in the\n call to `FlutterEnginePostDartObject` and must be collected by the\n embedder after that call is made."]
    pub string_value: *const ::std::os::raw::c_char,
    pub buffer_value: *const FlutterEngineDartBuffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineDartObject__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterEngineDartObject__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterEngineDartObject__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterEngineDartObject__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::bool_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, bool_value) - 0usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::int32_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, int32_value) - 0usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::int64_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, int64_value) - 0usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::double_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, double_value) - 0usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::string_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, string_value) - 0usize];
    ["Offset of field: FlutterEngineDartObject__bindgen_ty_1::buffer_value"]
        [::std::mem::offset_of!(FlutterEngineDartObject__bindgen_ty_1, buffer_value) - 0usize];
};
impl Default for FlutterEngineDartObject__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineDartObject"][::std::mem::size_of::<FlutterEngineDartObject>() - 16usize];
    ["Alignment of FlutterEngineDartObject"]
        [::std::mem::align_of::<FlutterEngineDartObject>() - 8usize];
    ["Offset of field: FlutterEngineDartObject::type_"]
        [::std::mem::offset_of!(FlutterEngineDartObject, type_) - 0usize];
};
impl Default for FlutterEngineDartObject {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The Flutter Engine considers the thread on which the FlutterEngineRun call\n is made to be the platform thread. There is only one such thread per\n engine instance."]
pub const FlutterNativeThreadType_kFlutterNativeThreadTypePlatform: FlutterNativeThreadType = 0;
#[doc = " This is the thread the Flutter Engine uses to execute rendering commands\n based on the selected client rendering API. There is only one such thread\n per engine instance."]
pub const FlutterNativeThreadType_kFlutterNativeThreadTypeRender: FlutterNativeThreadType = 1;
#[doc = " This is a dedicated thread on which the root Dart isolate is serviced.\n There is only one such thread per engine instance."]
pub const FlutterNativeThreadType_kFlutterNativeThreadTypeUI: FlutterNativeThreadType = 2;
#[doc = " Multiple threads are used by the Flutter engine to perform long running\n background tasks."]
pub const FlutterNativeThreadType_kFlutterNativeThreadTypeWorker: FlutterNativeThreadType = 3;
#[doc = " This enum allows embedders to determine the type of the engine thread in the\n FlutterNativeThreadCallback. Based on the thread type, the embedder may be\n able to tweak the thread priorities for optimum performance."]
pub type FlutterNativeThreadType = ::std::os::raw::c_int;
#[doc = " A callback made by the engine in response to\n `FlutterEnginePostCallbackOnAllNativeThreads` on all internal thread."]
pub type FlutterNativeThreadCallback = ::std::option::Option<
    unsafe extern "C" fn(type_: FlutterNativeThreadType, user_data: *mut ::std::os::raw::c_void),
>;
pub const FlutterEngineAOTDataSourceType_kFlutterEngineAOTDataSourceTypeElfPath:
    FlutterEngineAOTDataSourceType = 0;
#[doc = " AOT data source type."]
pub type FlutterEngineAOTDataSourceType = ::std::os::raw::c_int;
#[doc = " This struct specifies one of the various locations the engine can look for\n AOT data sources."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FlutterEngineAOTDataSource {
    pub type_: FlutterEngineAOTDataSourceType,
    pub __bindgen_anon_1: FlutterEngineAOTDataSource__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FlutterEngineAOTDataSource__bindgen_ty_1 {
    #[doc = " Absolute path to an ELF library file."]
    pub elf_path: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineAOTDataSource__bindgen_ty_1"]
        [::std::mem::size_of::<FlutterEngineAOTDataSource__bindgen_ty_1>() - 8usize];
    ["Alignment of FlutterEngineAOTDataSource__bindgen_ty_1"]
        [::std::mem::align_of::<FlutterEngineAOTDataSource__bindgen_ty_1>() - 8usize];
    ["Offset of field: FlutterEngineAOTDataSource__bindgen_ty_1::elf_path"]
        [::std::mem::offset_of!(FlutterEngineAOTDataSource__bindgen_ty_1, elf_path) - 0usize];
};
impl Default for FlutterEngineAOTDataSource__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineAOTDataSource"]
        [::std::mem::size_of::<FlutterEngineAOTDataSource>() - 16usize];
    ["Alignment of FlutterEngineAOTDataSource"]
        [::std::mem::align_of::<FlutterEngineAOTDataSource>() - 8usize];
    ["Offset of field: FlutterEngineAOTDataSource::type_"]
        [::std::mem::offset_of!(FlutterEngineAOTDataSource, type_) - 0usize];
};
impl Default for FlutterEngineAOTDataSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FlutterLogMessageCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FlutterEngineAOTData {
    _unused: [u8; 0],
}
#[doc = " An opaque object that describes the AOT data that can be used to launch a\n FlutterEngine instance in AOT mode."]
pub type FlutterEngineAOTData = *mut _FlutterEngineAOTData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FlutterProjectArgs {
    #[doc = " The size of this struct. Must be sizeof(FlutterProjectArgs)."]
    pub struct_size: usize,
    #[doc = " The path to the Flutter assets directory containing project assets. The\n string can be collected after the call to `FlutterEngineRun` returns. The\n string must be NULL terminated."]
    pub assets_path: *const ::std::os::raw::c_char,
    #[doc = " The path to the Dart file containing the `main` entry point.\n The string can be collected after the call to `FlutterEngineRun` returns.\n The string must be NULL terminated.\n\n @deprecated     As of Dart 2, running from Dart source is no longer\n                 supported. Dart code should now be compiled to kernel form\n                 and will be loaded by from `kernel_blob.bin` in the assets\n                 directory. This struct member is retained for ABI\n                 stability."]
    pub main_path__unused__: *const ::std::os::raw::c_char,
    #[doc = " The path to the `.packages` file for the project. The string can be\n collected after the call to `FlutterEngineRun` returns. The string must be\n NULL terminated.\n\n @deprecated    As of Dart 2, running from Dart source is no longer\n                supported. Dart code should now be compiled to kernel form\n                and will be loaded by from `kernel_blob.bin` in the assets\n                directory. This struct member is retained for ABI\n                stability."]
    pub packages_path__unused__: *const ::std::os::raw::c_char,
    #[doc = " The path to the `icudtl.dat` file for the project. The string can be\n collected after the call to `FlutterEngineRun` returns. The string must\n be NULL terminated."]
    pub icu_data_path: *const ::std::os::raw::c_char,
    #[doc = " The command line argument count used to initialize the project."]
    pub command_line_argc: ::std::os::raw::c_int,
    #[doc = " The command line arguments used to initialize the project. The strings can\n be collected after the call to `FlutterEngineRun` returns. The strings\n must be `NULL` terminated.\n\n @attention     The first item in the command line (if specified at all) is\n                interpreted as the executable name. So if an engine flag\n                needs to be passed into the same, it needs to not be the\n                very first item in the list.\n\n The set of engine flags are only meant to control\n unstable features in the engine. Deployed applications should not pass any\n command line arguments at all as they may affect engine stability at\n runtime in the presence of un-sanitized input. The list of currently\n recognized engine flags and their descriptions can be retrieved from the\n `switches.h` engine source file."]
    pub command_line_argv: *const *const ::std::os::raw::c_char,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to platform messages from the Dart application.\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made. The second parameter, `user_data`, is supplied when\n `FlutterEngineRun` or `FlutterEngineInitialize` is called."]
    pub platform_message_callback: FlutterPlatformMessageCallback,
    #[doc = " The VM snapshot data buffer used in AOT operation. This buffer must be\n mapped in as read-only. For more information refer to the documentation on\n the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub vm_snapshot_data: *const u8,
    #[doc = " The size of the VM snapshot data buffer.  If vm_snapshot_data is a symbol\n reference, 0 may be passed here."]
    pub vm_snapshot_data_size: usize,
    #[doc = " The VM snapshot instructions buffer used in AOT operation. This buffer\n must be mapped in as read-execute. For more information refer to the\n documentation on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub vm_snapshot_instructions: *const u8,
    #[doc = " The size of the VM snapshot instructions buffer. If\n vm_snapshot_instructions is a symbol reference, 0 may be passed here."]
    pub vm_snapshot_instructions_size: usize,
    #[doc = " The isolate snapshot data buffer used in AOT operation. This buffer must\n be mapped in as read-only. For more information refer to the documentation\n on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub isolate_snapshot_data: *const u8,
    #[doc = " The size of the isolate snapshot data buffer.  If isolate_snapshot_data is\n a symbol reference, 0 may be passed here."]
    pub isolate_snapshot_data_size: usize,
    #[doc = " The isolate snapshot instructions buffer used in AOT operation. This\n buffer must be mapped in as read-execute. For more information refer to\n the documentation on the Wiki at\n https://github.com/flutter/flutter/wiki/Flutter-engine-operation-in-AOT-Mode"]
    pub isolate_snapshot_instructions: *const u8,
    #[doc = " The size of the isolate snapshot instructions buffer. If\n isolate_snapshot_instructions is a symbol reference, 0 may be passed here."]
    pub isolate_snapshot_instructions_size: usize,
    #[doc = " The callback invoked by the engine in root isolate scope. Called\n immediately after the root isolate has been created and marked runnable."]
    pub root_isolate_create_callback: VoidCallback,
    #[doc = " The legacy callback invoked by the engine in order to give the embedder\n the chance to respond to semantics node updates from the Dart application.\n Semantics node updates are sent in batches terminated by a 'batch end'\n callback that is passed a sentinel `FlutterSemanticsNode` whose `id` field\n has the value `kFlutterSemanticsNodeIdBatchEnd`.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                should be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_node_callback: FlutterUpdateSemanticsNodeCallback,
    #[doc = " The legacy callback invoked by the engine in order to give the embedder\n the chance to respond to updates to semantics custom actions from the Dart\n application. Custom action updates are sent in batches terminated by a\n 'batch end' callback that is passed a sentinel\n `FlutterSemanticsCustomAction` whose `id` field has the value\n `kFlutterSemanticsCustomActionIdBatchEnd`.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                should be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_custom_action_callback: FlutterUpdateSemanticsCustomActionCallback,
    #[doc = " Path to a directory used to store data that is cached across runs of a\n Flutter application (such as compiled shader programs used by Skia).\n This is optional.  The string must be NULL terminated.\n"]
    pub persistent_cache_path: *const ::std::os::raw::c_char,
    #[doc = " If true, the engine would only read the existing cache, but not write new\n ones."]
    pub is_persistent_cache_read_only: bool,
    #[doc = " A callback that gets invoked by the engine when it attempts to wait for a\n platform vsync event. The engine will give the platform a baton that needs\n to be returned back to the engine via `FlutterEngineOnVsync`. All batons\n must be retured to the engine before initializing a\n `FlutterEngineShutdown`. Not doing the same will result in a memory leak.\n While the call to `FlutterEngineOnVsync` must occur on the thread that\n made the call to `FlutterEngineRun`, the engine will make this callback on\n an internal engine-managed thread. If the components accessed on the\n embedder are not thread safe, the appropriate re-threading must be done."]
    pub vsync_callback: VsyncCallback,
    #[doc = " The name of a custom Dart entrypoint. This is optional and specifying a\n null or empty entrypoint makes the engine look for a method named \"main\"\n in the root library of the application.\n\n Care must be taken to ensure that the custom entrypoint is not tree-shaken\n away. Usually, this is done using the `@pragma('vm:entry-point')`\n decoration."]
    pub custom_dart_entrypoint: *const ::std::os::raw::c_char,
    #[doc = " Typically the Flutter engine create and manages its internal threads. This\n optional argument allows for the specification of task runner interfaces\n to event loops managed by the embedder on threads it creates."]
    pub custom_task_runners: *const FlutterCustomTaskRunners,
    #[doc = " All `FlutterEngine` instances in the process share the same Dart VM. When\n the first engine is launched, it starts the Dart VM as well. It used to be\n the case that it was not possible to shutdown the Dart VM cleanly and\n start it back up in the process in a safe manner. This issue has since\n been patched. Unfortunately, applications already began to make use of the\n fact that shutting down the Flutter engine instance left a running VM in\n the process. Since a Flutter engine could be launched on any thread,\n applications would \"warm up\" the VM on another thread by launching\n an engine with no isolates and then shutting it down immediately. The main\n Flutter application could then be started on the main thread without\n having to incur the Dart VM startup costs at that time. With the new\n behavior, this \"optimization\" immediately becomes massive performance\n pessimization as the VM would be started up in the \"warm up\" phase, shut\n down there and then started again on the main thread. Changing this\n behavior was deemed to be an unacceptable breaking change. Embedders that\n wish to shutdown the Dart VM when the last engine is terminated in the\n process should opt into this behavior by setting this flag to true."]
    pub shutdown_dart_vm_when_done: bool,
    #[doc = " Typically, Flutter renders the layer hierarchy into a single root surface.\n However, when embedders need to interleave their own contents within the\n Flutter layer hierarchy, their applications can push platform views within\n the Flutter scene. This is done using the `SceneBuilder.addPlatformView`\n call. When this happens, the Flutter rasterizer divides the effective view\n hierarchy into multiple layers. Each layer gets its own backing store and\n Flutter renders into the same. Once the layers contents have been\n fulfilled, the embedder is asked to composite these layers on-screen. At\n this point, it can interleave its own contents within the effective\n hierarchy. The interface for the specification of these layer backing\n stores and the hooks to listen for the composition of layers on-screen can\n be controlled using this field. This field is completely optional. In its\n absence, platforms views in the scene are ignored and Flutter renders to\n the root surface as normal."]
    pub compositor: *const FlutterCompositor,
    #[doc = " Max size of the old gen heap for the Dart VM in MB, or 0 for unlimited, -1\n for default value.\n\n See also:\n https://github.com/dart-lang/sdk/blob/ca64509108b3e7219c50d6c52877c85ab6a35ff2/runtime/vm/flag_list.h#L150"]
    pub dart_old_gen_heap_size: i64,
    #[doc = " The AOT data to be used in AOT operation.\n\n Embedders should instantiate and destroy this object via the\n FlutterEngineCreateAOTData and FlutterEngineCollectAOTData methods.\n\n Embedders can provide either snapshot buffers or aot_data, but not both."]
    pub aot_data: FlutterEngineAOTData,
    #[doc = " A callback that computes the locale the platform would natively resolve\n to.\n\n The input parameter is an array of FlutterLocales which represent the\n locales supported by the app. One of the input supported locales should\n be selected and returned to best match with the user/device's preferred\n locale. The implementation should produce a result that as closely\n matches what the platform would natively resolve to as possible."]
    pub compute_platform_resolved_locale_callback: FlutterComputePlatformResolvedLocaleCallback,
    #[doc = " The command line argument count for arguments passed through to the Dart\n entrypoint."]
    pub dart_entrypoint_argc: ::std::os::raw::c_int,
    #[doc = " The command line arguments passed through to the Dart entrypoint. The\n strings must be `NULL` terminated.\n\n The strings will be copied out and so any strings passed in here can\n be safely collected after initializing the engine with\n `FlutterProjectArgs`."]
    pub dart_entrypoint_argv: *const *const ::std::os::raw::c_char,
    pub log_message_callback: FlutterLogMessageCallback,
    pub log_tag: *const ::std::os::raw::c_char,
    pub on_pre_engine_restart_callback: OnPreEngineRestartCallback,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to updates to semantics nodes and custom actions from\n the Dart application.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n @deprecated    Use `update_semantics_callback2` instead. Only one of\n                `update_semantics_node_callback`,\n                `update_semantics_callback`, and\n                `update_semantics_callback2` may be provided; the others\n                must be set to null.\n\n                This callback is incompatible with multiple views. If this\n                callback is provided, `FlutterEngineAddView` and\n                `FlutterEngineRemoveView` should not be used."]
    pub update_semantics_callback: FlutterUpdateSemanticsCallback,
    #[doc = " The callback invoked by the engine in order to give the embedder the\n chance to respond to updates to semantics nodes and custom actions from\n the Dart application.\n\n The callback will be invoked on the thread on which the `FlutterEngineRun`\n call is made.\n\n Only one of `update_semantics_node_callback`, `update_semantics_callback`,\n and `update_semantics_callback2` may be provided; the others must be set\n to null."]
    pub update_semantics_callback2: FlutterUpdateSemanticsCallback2,
    #[doc = " The callback invoked by the engine in response to a channel listener\n being registered on the framework side. The callback is invoked from\n a task posted to the platform thread."]
    pub channel_update_callback: FlutterChannelUpdateCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterProjectArgs"][::std::mem::size_of::<FlutterProjectArgs>() - 296usize];
    ["Alignment of FlutterProjectArgs"][::std::mem::align_of::<FlutterProjectArgs>() - 8usize];
    ["Offset of field: FlutterProjectArgs::struct_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, struct_size) - 0usize];
    ["Offset of field: FlutterProjectArgs::assets_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, assets_path) - 8usize];
    ["Offset of field: FlutterProjectArgs::main_path__unused__"]
        [::std::mem::offset_of!(FlutterProjectArgs, main_path__unused__) - 16usize];
    ["Offset of field: FlutterProjectArgs::packages_path__unused__"]
        [::std::mem::offset_of!(FlutterProjectArgs, packages_path__unused__) - 24usize];
    ["Offset of field: FlutterProjectArgs::icu_data_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, icu_data_path) - 32usize];
    ["Offset of field: FlutterProjectArgs::command_line_argc"]
        [::std::mem::offset_of!(FlutterProjectArgs, command_line_argc) - 40usize];
    ["Offset of field: FlutterProjectArgs::command_line_argv"]
        [::std::mem::offset_of!(FlutterProjectArgs, command_line_argv) - 48usize];
    ["Offset of field: FlutterProjectArgs::platform_message_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, platform_message_callback) - 56usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_data) - 64usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_data_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_data_size) - 72usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_instructions"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_instructions) - 80usize];
    ["Offset of field: FlutterProjectArgs::vm_snapshot_instructions_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, vm_snapshot_instructions_size) - 88usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_data) - 96usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_data_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_data_size) - 104usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_instructions"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_instructions) - 112usize];
    ["Offset of field: FlutterProjectArgs::isolate_snapshot_instructions_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, isolate_snapshot_instructions_size) - 120usize];
    ["Offset of field: FlutterProjectArgs::root_isolate_create_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, root_isolate_create_callback) - 128usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_node_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_node_callback) - 136usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_custom_action_callback"][::std::mem::offset_of!(
        FlutterProjectArgs,
        update_semantics_custom_action_callback
    ) - 144usize];
    ["Offset of field: FlutterProjectArgs::persistent_cache_path"]
        [::std::mem::offset_of!(FlutterProjectArgs, persistent_cache_path) - 152usize];
    ["Offset of field: FlutterProjectArgs::is_persistent_cache_read_only"]
        [::std::mem::offset_of!(FlutterProjectArgs, is_persistent_cache_read_only) - 160usize];
    ["Offset of field: FlutterProjectArgs::vsync_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, vsync_callback) - 168usize];
    ["Offset of field: FlutterProjectArgs::custom_dart_entrypoint"]
        [::std::mem::offset_of!(FlutterProjectArgs, custom_dart_entrypoint) - 176usize];
    ["Offset of field: FlutterProjectArgs::custom_task_runners"]
        [::std::mem::offset_of!(FlutterProjectArgs, custom_task_runners) - 184usize];
    ["Offset of field: FlutterProjectArgs::shutdown_dart_vm_when_done"]
        [::std::mem::offset_of!(FlutterProjectArgs, shutdown_dart_vm_when_done) - 192usize];
    ["Offset of field: FlutterProjectArgs::compositor"]
        [::std::mem::offset_of!(FlutterProjectArgs, compositor) - 200usize];
    ["Offset of field: FlutterProjectArgs::dart_old_gen_heap_size"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_old_gen_heap_size) - 208usize];
    ["Offset of field: FlutterProjectArgs::aot_data"]
        [::std::mem::offset_of!(FlutterProjectArgs, aot_data) - 216usize];
    ["Offset of field: FlutterProjectArgs::compute_platform_resolved_locale_callback"][::std::mem::offset_of!(
        FlutterProjectArgs,
        compute_platform_resolved_locale_callback
    )
        - 224usize];
    ["Offset of field: FlutterProjectArgs::dart_entrypoint_argc"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_entrypoint_argc) - 232usize];
    ["Offset of field: FlutterProjectArgs::dart_entrypoint_argv"]
        [::std::mem::offset_of!(FlutterProjectArgs, dart_entrypoint_argv) - 240usize];
    ["Offset of field: FlutterProjectArgs::log_message_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, log_message_callback) - 248usize];
    ["Offset of field: FlutterProjectArgs::log_tag"]
        [::std::mem::offset_of!(FlutterProjectArgs, log_tag) - 256usize];
    ["Offset of field: FlutterProjectArgs::on_pre_engine_restart_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, on_pre_engine_restart_callback) - 264usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_callback) - 272usize];
    ["Offset of field: FlutterProjectArgs::update_semantics_callback2"]
        [::std::mem::offset_of!(FlutterProjectArgs, update_semantics_callback2) - 280usize];
    ["Offset of field: FlutterProjectArgs::channel_update_callback"]
        [::std::mem::offset_of!(FlutterProjectArgs, channel_update_callback) - 288usize];
};
impl Default for FlutterProjectArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " @brief      Creates the necessary data structures to launch a Flutter Dart\n             application in AOT mode. The data may only be collected after\n             all FlutterEngine instances launched using this data have been\n             terminated.\n\n @param[in]  source    The source of the AOT data.\n @param[out] data_out  The AOT data on success. Unchanged on failure.\n\n @return     Returns if the AOT data could be successfully resolved.\n"]
    pub fn FlutterEngineCreateAOTData(
        source: *const FlutterEngineAOTDataSource,
        data_out: *mut FlutterEngineAOTData,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Collects the AOT data.\n\n @warning    The embedder must ensure that this call is made only after all\n             FlutterEngine instances launched using this data have been\n             terminated, and that all of those instances were launched with\n             the FlutterProjectArgs::shutdown_dart_vm_when_done flag set to\n             true.\n\n @param[in]  data   The data to collect.\n\n @return     Returns if the AOT data was successfully collected.\n"]
    pub fn FlutterEngineCollectAOTData(data: FlutterEngineAOTData) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Initialize and run a Flutter engine instance and return a handle\n             to it. This is a convenience method for the pair of calls to\n             `FlutterEngineInitialize` and `FlutterEngineRunInitialized`.\n\n @note       This method of running a Flutter engine works well except in\n             cases where the embedder specifies custom task runners via\n             `FlutterProjectArgs::custom_task_runners`. In such cases, the\n             engine may need the embedder to post tasks back to it before\n             `FlutterEngineRun` has returned. Embedders can only post tasks\n             to the engine if they have a handle to the engine. In such\n             cases, embedders are advised to get the engine handle via the\n             `FlutterInitializeCall`. Then they can call\n             `FlutterEngineRunInitialized` knowing that they will be able to\n             service custom tasks on other threads with the engine handle.\n\n @param[in]  version    The Flutter embedder API version. Must be\n                        FLUTTER_ENGINE_VERSION.\n @param[in]  config     The renderer configuration.\n @param[in]  args       The Flutter project arguments.\n @param      user_data  A user data baton passed back to embedders in\n                        callbacks.\n @param[out] engine_out The engine handle on successful engine creation.\n\n @return     The result of the call to run the Flutter engine.\n"]
    pub fn FlutterEngineRun(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Shuts down a Flutter engine instance. The engine handle is no\n             longer valid for any calls in the embedder API after this point.\n             Making additional calls with this handle is undefined behavior.\n\n @note       This de-initializes the Flutter engine instance (via an implicit\n             call to `FlutterEngineDeinitialize`) if necessary.\n\n @param[in]  engine  The Flutter engine instance to collect.\n\n @return     The result of the call to shutdown the Flutter engine instance.\n"]
    pub fn FlutterEngineShutdown(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Initialize a Flutter engine instance. This does not run the\n             Flutter application code till the `FlutterEngineRunInitialized`\n             call is made. Besides Flutter application code, no tasks are\n             scheduled on embedder managed task runners either. This allows\n             embedders providing custom task runners to the Flutter engine to\n             obtain a handle to the Flutter engine before the engine can post\n             tasks on these task runners.\n\n @param[in]  version    The Flutter embedder API version. Must be\n                        FLUTTER_ENGINE_VERSION.\n @param[in]  config     The renderer configuration.\n @param[in]  args       The Flutter project arguments.\n @param      user_data  A user data baton passed back to embedders in\n                        callbacks.\n @param[out] engine_out The engine handle on successful engine creation.\n\n @return     The result of the call to initialize the Flutter engine.\n"]
    pub fn FlutterEngineInitialize(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Stops running the Flutter engine instance. After this call, the\n             embedder is also guaranteed that no more calls to post tasks\n             onto custom task runners specified by the embedder are made. The\n             Flutter engine handle still needs to be collected via a call to\n             `FlutterEngineShutdown`.\n\n @param[in]  engine    The running engine instance to de-initialize.\n\n @return     The result of the call to de-initialize the Flutter engine.\n"]
    pub fn FlutterEngineDeinitialize(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Runs an initialized engine instance. An engine can be\n             initialized via `FlutterEngineInitialize`. An initialized\n             instance can only be run once. During and after this call,\n             custom task runners supplied by the embedder are expected to\n             start servicing tasks.\n\n @param[in]  engine  An initialized engine instance that has not previously\n                     been run.\n\n @return     The result of the call to run the initialized Flutter\n             engine instance.\n"]
    pub fn FlutterEngineRunInitialized(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Adds a view.\n\n             This is an asynchronous operation. The view should not be used\n             until the |info.add_view_callback| is invoked with an |added|\n             value of true. The embedder should prepare resources in advance\n             but be ready to clean up on failure.\n\n             A frame is scheduled if the operation succeeds.\n\n             The callback is invoked on a thread managed by the engine. The\n             embedder should re-thread if needed.\n\n             Attempting to add the implicit view will fail and will return\n             kInvalidArguments. Attempting to add a view with an already\n             existing view ID will fail, and |info.add_view_callback| will be\n             invoked with an |added| value of false.\n\n @param[in]  engine  A running engine instance.\n @param[in]  info    The add view arguments. This can be deallocated\n                     once |FlutterEngineAddView| returns, before\n                     |add_view_callback| is invoked.\n\n @return     The result of *starting* the asynchronous operation. If\n             `kSuccess`, the |add_view_callback| will be invoked."]
    pub fn FlutterEngineAddView(
        engine: FlutterEngine,
        info: *const FlutterAddViewInfo,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Removes a view.\n\n             This is an asynchronous operation. The view's resources must not\n             be cleaned up until |info.remove_view_callback| is invoked with\n             a |removed| value of true.\n\n             The callback is invoked on a thread managed by the engine. The\n             embedder should re-thread if needed.\n\n             Attempting to remove the implicit view will fail and will return\n             kInvalidArguments. Attempting to remove a view with a\n             non-existent view ID will fail, and |info.remove_view_callback|\n             will be invoked with a |removed| value of false.\n\n @param[in]  engine  A running engine instance.\n @param[in]  info    The remove view arguments. This can be deallocated\n                     once |FlutterEngineRemoveView| returns, before\n                     |remove_view_callback| is invoked.\n\n @return     The result of *starting* the asynchronous operation. If\n             `kSuccess`, the |remove_view_callback| will be invoked."]
    pub fn FlutterEngineRemoveView(
        engine: FlutterEngine,
        info: *const FlutterRemoveViewInfo,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendWindowMetricsEvent(
        engine: FlutterEngine,
        event: *const FlutterWindowMetricsEvent,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendPointerEvent(
        engine: FlutterEngine,
        events: *const FlutterPointerEvent,
        events_count: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Sends a key event to the engine. The framework will decide\n             whether to handle this event in a synchronous fashion, although\n             due to technical limitation, the result is always reported\n             asynchronously. The `callback` is guaranteed to be called\n             exactly once.\n\n @param[in]  engine         A running engine instance.\n @param[in]  event          The event data to be sent. This function will no\n                            longer access `event` after returning.\n @param[in]  callback       The callback invoked by the engine when the\n                            Flutter application has decided whether it\n                            handles this event. Accepts nullptr.\n @param[in]  user_data      The context associated with the callback. The\n                            exact same value will used to invoke `callback`.\n                            Accepts nullptr.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineSendKeyEvent(
        engine: FlutterEngine,
        event: *const FlutterKeyEvent,
        callback: FlutterKeyEventCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    pub fn FlutterEngineSendPlatformMessage(
        engine: FlutterEngine,
        message: *const FlutterPlatformMessage,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief     Creates a platform message response handle that allows the\n            embedder to set a native callback for a response to a message.\n            This handle may be set on the `response_handle` field of any\n            `FlutterPlatformMessage` sent to the engine.\n\n            The handle must be collected via a call to\n            `FlutterPlatformMessageReleaseResponseHandle`. This may be done\n            immediately after a call to `FlutterEngineSendPlatformMessage`\n            with a platform message whose response handle contains the handle\n            created using this call. In case a handle is created but never\n            sent in a message, the release call must still be made. Not\n            calling release on the handle results in a small memory leak.\n\n            The user data baton passed to the data callback is the one\n            specified in this call as the third argument.\n\n @see       FlutterPlatformMessageReleaseResponseHandle()\n\n @param[in]  engine         A running engine instance.\n @param[in]  data_callback  The callback invoked by the engine when the\n                            Flutter application send a response on the\n                            handle.\n @param[in]  user_data      The user data associated with the data callback.\n @param[out] response_out   The response handle created when this call is\n                            successful.\n\n @return     The result of the call.\n"]
    pub fn FlutterPlatformMessageCreateResponseHandle(
        engine: FlutterEngine,
        data_callback: FlutterDataCallback,
        user_data: *mut ::std::os::raw::c_void,
        response_out: *mut *mut FlutterPlatformMessageResponseHandle,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Collects the handle created using\n             `FlutterPlatformMessageCreateResponseHandle`.\n\n @see        FlutterPlatformMessageCreateResponseHandle()\n\n @param[in]  engine     A running engine instance.\n @param[in]  response   The platform message response handle to collect.\n                        These handles are created using\n                        `FlutterPlatformMessageCreateResponseHandle()`.\n\n @return     The result of the call.\n"]
    pub fn FlutterPlatformMessageReleaseResponseHandle(
        engine: FlutterEngine,
        response: *mut FlutterPlatformMessageResponseHandle,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Send a response from the native side to a platform message from\n             the Dart Flutter application.\n\n @param[in]  engine       The running engine instance.\n @param[in]  handle       The platform message response handle.\n @param[in]  data         The data to associate with the platform message\n                          response.\n @param[in]  data_length  The length of the platform message response data.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineSendPlatformMessageResponse(
        engine: FlutterEngine,
        handle: *const FlutterPlatformMessageResponseHandle,
        data: *const u8,
        data_length: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      This API is only meant to be used by platforms that need to\n             flush tasks on a message loop not controlled by the Flutter\n             engine.\n\n @deprecated This API will be deprecated and is not part of the stable API.\n             Please use the custom task runners API by setting an\n             appropriate `FlutterProjectArgs::custom_task_runners`\n             interface. This will yield better performance and the\n             interface is stable.\n\n @return     The result of the call.\n"]
    pub fn __FlutterEngineFlushPendingTasksNow() -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Register an external texture with a unique (per engine)\n             identifier. Only rendering backends that support external\n             textures accept external texture registrations. After the\n             external texture is registered, the application can mark that a\n             frame is available by calling\n             `FlutterEngineMarkExternalTextureFrameAvailable`.\n\n @see        FlutterEngineUnregisterExternalTexture()\n @see        FlutterEngineMarkExternalTextureFrameAvailable()\n\n @param[in]  engine              A running engine instance.\n @param[in]  texture_identifier  The identifier of the texture to register\n                                 with the engine. The embedder may supply new\n                                 frames to this texture using the same\n                                 identifier.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineRegisterExternalTexture(
        engine: FlutterEngine,
        texture_identifier: i64,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Unregister a previous texture registration.\n\n @see        FlutterEngineRegisterExternalTexture()\n @see        FlutterEngineMarkExternalTextureFrameAvailable()\n\n @param[in]  engine              A running engine instance.\n @param[in]  texture_identifier  The identifier of the texture for which new\n                                 frame will not be available.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineUnregisterExternalTexture(
        engine: FlutterEngine,
        texture_identifier: i64,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Mark that a new texture frame is available for a given texture\n             identifier.\n\n @see        FlutterEngineRegisterExternalTexture()\n @see        FlutterEngineUnregisterExternalTexture()\n\n @param[in]  engine              A running engine instance.\n @param[in]  texture_identifier  The identifier of the texture whose frame\n                                 has been updated.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineMarkExternalTextureFrameAvailable(
        engine: FlutterEngine,
        texture_identifier: i64,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Enable or disable accessibility semantics.\n\n @param[in]  engine     A running engine instance.\n @param[in]  enabled    When enabled, changes to the semantic contents of the\n                        window are sent via the\n                        `FlutterUpdateSemanticsCallback2` registered to\n                        `update_semantics_callback2` in\n                        `FlutterProjectArgs`.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineUpdateSemanticsEnabled(
        engine: FlutterEngine,
        enabled: bool,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Sets additional accessibility features.\n\n @param[in]  engine     A running engine instance\n @param[in]  features   The accessibility features to set.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineUpdateAccessibilityFeatures(
        engine: FlutterEngine,
        features: FlutterAccessibilityFeature,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Dispatch a semantics action to the specified semantics node.\n\n @param[in]  engine       A running engine instance.\n @param[in]  node_id      The semantics node identifier.\n @param[in]  action       The semantics action.\n @param[in]  data         Data associated with the action.\n @param[in]  data_length  The data length.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineDispatchSemanticsAction(
        engine: FlutterEngine,
        node_id: u64,
        action: FlutterSemanticsAction,
        data: *const u8,
        data_length: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Notify the engine that a vsync event occurred. A baton passed to\n             the platform via the vsync callback must be returned. This call\n             must be made on the thread on which the call to\n             `FlutterEngineRun` was made.\n\n @see        FlutterEngineGetCurrentTime()\n\n @attention  That frame timepoints are in nanoseconds.\n\n @attention  The system monotonic clock is used as the timebase.\n\n @param[in]  engine.                  A running engine instance.\n @param[in]  baton                    The baton supplied by the engine.\n @param[in]  frame_start_time_nanos   The point at which the vsync event\n                                      occurred or will occur. If the time\n                                      point is in the future, the engine will\n                                      wait till that point to begin its frame\n                                      workload.\n @param[in]  frame_target_time_nanos  The point at which the embedder\n                                      anticipates the next vsync to occur.\n                                      This is a hint the engine uses to\n                                      schedule Dart VM garbage collection in\n                                      periods in which the various threads\n                                      are most likely to be idle. For\n                                      example, for a 60Hz display, embedders\n                                      should add 16.6 * 1e6 to the frame time\n                                      field.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineOnVsync(
        engine: FlutterEngine,
        baton: isize,
        frame_start_time_nanos: u64,
        frame_target_time_nanos: u64,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Reloads the system fonts in engine.\n\n @param[in]  engine.                  A running engine instance.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineReloadSystemFonts(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      A profiling utility. Logs a trace duration begin event to the\n             timeline. If the timeline is unavailable or disabled, this has\n             no effect. Must be balanced with an duration end event (via\n             `FlutterEngineTraceEventDurationEnd`) with the same name on the\n             same thread. Can be called on any thread. Strings passed into\n             the function will NOT be copied when added to the timeline. Only\n             string literals may be passed in.\n\n @param[in]  name  The name of the trace event.\n"]
    pub fn FlutterEngineTraceEventDurationBegin(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief      A profiling utility. Logs a trace duration end event to the\n             timeline. If the timeline is unavailable or disabled, this has\n             no effect. This call must be preceded by a trace duration begin\n             call (via `FlutterEngineTraceEventDurationBegin`) with the same\n             name on the same thread. Can be called on any thread. Strings\n             passed into the function will NOT be copied when added to the\n             timeline. Only string literals may be passed in.\n\n @param[in]  name  The name of the trace event.\n"]
    pub fn FlutterEngineTraceEventDurationEnd(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief      A profiling utility. Logs a trace duration instant event to the\n             timeline. If the timeline is unavailable or disabled, this has\n             no effect. Can be called on any thread. Strings passed into the\n             function will NOT be copied when added to the timeline. Only\n             string literals may be passed in.\n\n @param[in]  name  The name of the trace event.\n"]
    pub fn FlutterEngineTraceEventInstant(name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " @brief      Posts a task onto the Flutter render thread. Typically, this may\n             be called from any thread as long as a `FlutterEngineShutdown`\n             on the specific engine has not already been initiated.\n\n @param[in]  engine         A running engine instance.\n @param[in]  callback       The callback to execute on the render thread.\n @param      callback_data  The callback context.\n\n @return     The result of the call.\n"]
    pub fn FlutterEnginePostRenderThreadTask(
        engine: FlutterEngine,
        callback: VoidCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Get the current time in nanoseconds from the clock used by the\n             flutter engine. This is the system monotonic clock.\n\n @return     The current time in nanoseconds.\n"]
    pub fn FlutterEngineGetCurrentTime() -> u64;
}
unsafe extern "C" {
    #[doc = " @brief      Inform the engine to run the specified task. This task has been\n             given to the engine via the\n             `FlutterTaskRunnerDescription.post_task_callback`. This call\n             must only be made at the target time specified in that callback.\n             Running the task before that time is undefined behavior.\n\n @param[in]  engine     A running engine instance.\n @param[in]  task       the task handle.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineRunTask(
        engine: FlutterEngine,
        task: *const FlutterTask,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Notify a running engine instance that the locale has been\n             updated. The preferred locale must be the first item in the list\n             of locales supplied. The other entries will be used as a\n             fallback.\n\n @param[in]  engine         A running engine instance.\n @param[in]  locales        The updated locales in the order of preference.\n @param[in]  locales_count  The count of locales supplied.\n\n @return     Whether the locale updates were applied.\n"]
    pub fn FlutterEngineUpdateLocales(
        engine: FlutterEngine,
        locales: *mut *const FlutterLocale,
        locales_count: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Returns if the Flutter engine instance will run AOT compiled\n             Dart code. This call has no threading restrictions.\n\n             For embedder code that is configured for both AOT and JIT mode\n             Dart execution based on the Flutter engine being linked to, this\n             runtime check may be used to appropriately configure the\n             `FlutterProjectArgs`. In JIT mode execution, the kernel\n             snapshots must be present in the Flutter assets directory\n             specified in the `FlutterProjectArgs`. For AOT execution, the\n             fields `vm_snapshot_data`, `vm_snapshot_instructions`,\n             `isolate_snapshot_data` and `isolate_snapshot_instructions`\n             (along with their size fields) must be specified in\n             `FlutterProjectArgs`.\n\n @return     True, if AOT Dart code is run. JIT otherwise.\n"]
    pub fn FlutterEngineRunsAOTCompiledDartCode() -> bool;
}
unsafe extern "C" {
    #[doc = " @brief      Posts a Dart object to specified send port. The corresponding\n             receive port for send port can be in any isolate running in the\n             VM. This isolate can also be the root isolate for an\n             unrelated engine. The engine parameter is necessary only to\n             ensure the call is not made when no engine (and hence no VM) is\n             running.\n\n             Unlike the platform messages mechanism, there are no threading\n             restrictions when using this API. Message can be posted on any\n             thread and they will be made available to isolate on which the\n             corresponding send port is listening.\n\n             However, it is the embedders responsibility to ensure that the\n             call is not made during an ongoing call the\n             `FlutterEngineDeinitialize` or `FlutterEngineShutdown` on\n             another thread.\n\n @param[in]  engine     A running engine instance.\n @param[in]  port       The send port to send the object to.\n @param[in]  object     The object to send to the isolate with the\n                        corresponding receive port.\n\n @return     If the message was posted to the send port.\n"]
    pub fn FlutterEnginePostDartObject(
        engine: FlutterEngine,
        port: FlutterEngineDartPort,
        object: *const FlutterEngineDartObject,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Posts a low memory notification to a running engine instance.\n             The engine will do its best to release non-critical resources in\n             response. It is not guaranteed that the resource would have been\n             collected by the time this call returns however. The\n             notification is posted to engine subsystems that may be\n             operating on other threads.\n\n             Flutter applications can respond to these notifications by\n             setting `WidgetsBindingObserver.didHaveMemoryPressure`\n             observers.\n\n @param[in]  engine     A running engine instance.\n\n @return     If the low memory notification was sent to the running engine\n             instance.\n"]
    pub fn FlutterEngineNotifyLowMemoryWarning(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Schedule a callback to be run on all engine managed threads.\n             The engine will attempt to service this callback the next time\n             the message loop for each managed thread is idle. Since the\n             engine manages the entire lifecycle of multiple threads, there\n             is no opportunity for the embedders to finely tune the\n             priorities of threads directly, or, perform other thread\n             specific configuration (for example, setting thread names for\n             tracing). This callback gives embedders a chance to affect such\n             tuning.\n\n @attention  This call is expensive and must be made as few times as\n             possible. The callback must also return immediately as not doing\n             so may risk performance issues (especially for callbacks of type\n             kFlutterNativeThreadTypeUI and kFlutterNativeThreadTypeRender).\n\n @attention  Some callbacks (especially the ones of type\n             kFlutterNativeThreadTypeWorker) may be called after the\n             FlutterEngine instance has shut down. Embedders must be careful\n             in handling the lifecycle of objects associated with the user\n             data baton.\n\n @attention  In case there are multiple running Flutter engine instances,\n             their workers are shared.\n\n @param[in]  engine     A running engine instance.\n @param[in]  callback   The callback that will get called multiple times on\n                        each engine managed thread.\n @param[in]  user_data  A baton passed by the engine to the callback. This\n                        baton is not interpreted by the engine in any way.\n\n @return     Returns if the callback was successfully posted to all threads.\n"]
    pub fn FlutterEnginePostCallbackOnAllNativeThreads(
        engine: FlutterEngine,
        callback: FlutterNativeThreadCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief    Posts updates corresponding to display changes to a running engine\n           instance.\n\n @param[in] update_type      The type of update pushed to the engine.\n @param[in] displays         The displays affected by this update.\n @param[in] display_count    Size of the displays array, must be at least 1.\n\n @return the result of the call made to the engine.\n"]
    pub fn FlutterEngineNotifyDisplayUpdate(
        engine: FlutterEngine,
        update_type: FlutterEngineDisplaysUpdateType,
        displays: *const FlutterEngineDisplay,
        display_count: usize,
    ) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Schedule a new frame to redraw the content.\n\n @param[in]  engine     A running engine instance.\n\n @return the result of the call made to the engine.\n"]
    pub fn FlutterEngineScheduleFrame(engine: FlutterEngine) -> FlutterEngineResult;
}
unsafe extern "C" {
    #[doc = " @brief      Schedule a callback to be called after the next frame is drawn.\n             This must be called from the platform thread. The callback is\n             executed only once from the raster thread; embedders must\n             re-thread if necessary. Performing blocking calls\n             in this callback may introduce application jank.\n\n @param[in]  engine     A running engine instance.\n @param[in]  callback   The callback to execute.\n @param[in]  user_data  A baton passed by the engine to the callback. This\n                        baton is not interpreted by the engine in any way.\n\n @return     The result of the call.\n"]
    pub fn FlutterEngineSetNextFrameCallback(
        engine: FlutterEngine,
        callback: VoidCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult;
}
pub type FlutterEngineCreateAOTDataFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        source: *const FlutterEngineAOTDataSource,
        data_out: *mut FlutterEngineAOTData,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineCollectAOTDataFnPtr =
    ::std::option::Option<unsafe extern "C" fn(data: FlutterEngineAOTData) -> FlutterEngineResult>;
pub type FlutterEngineRunFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineShutdownFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEngineInitializeFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        version: usize,
        config: *const FlutterRendererConfig,
        args: *const FlutterProjectArgs,
        user_data: *mut ::std::os::raw::c_void,
        engine_out: *mut FlutterEngine,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineDeinitializeFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEngineRunInitializedFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEngineSendWindowMetricsEventFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        event: *const FlutterWindowMetricsEvent,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineSendPointerEventFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        events: *const FlutterPointerEvent,
        events_count: usize,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineSendKeyEventFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        event: *const FlutterKeyEvent,
        callback: FlutterKeyEventCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineSendPlatformMessageFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        message: *const FlutterPlatformMessage,
    ) -> FlutterEngineResult,
>;
pub type FlutterEnginePlatformMessageCreateResponseHandleFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        data_callback: FlutterDataCallback,
        user_data: *mut ::std::os::raw::c_void,
        response_out: *mut *mut FlutterPlatformMessageResponseHandle,
    ) -> FlutterEngineResult,
>;
pub type FlutterEnginePlatformMessageReleaseResponseHandleFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        response: *mut FlutterPlatformMessageResponseHandle,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineSendPlatformMessageResponseFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        handle: *const FlutterPlatformMessageResponseHandle,
        data: *const u8,
        data_length: usize,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineRegisterExternalTextureFnPtr = ::std::option::Option<
    unsafe extern "C" fn(engine: FlutterEngine, texture_identifier: i64) -> FlutterEngineResult,
>;
pub type FlutterEngineUnregisterExternalTextureFnPtr = ::std::option::Option<
    unsafe extern "C" fn(engine: FlutterEngine, texture_identifier: i64) -> FlutterEngineResult,
>;
pub type FlutterEngineMarkExternalTextureFrameAvailableFnPtr = ::std::option::Option<
    unsafe extern "C" fn(engine: FlutterEngine, texture_identifier: i64) -> FlutterEngineResult,
>;
pub type FlutterEngineUpdateSemanticsEnabledFnPtr = ::std::option::Option<
    unsafe extern "C" fn(engine: FlutterEngine, enabled: bool) -> FlutterEngineResult,
>;
pub type FlutterEngineUpdateAccessibilityFeaturesFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        features: FlutterAccessibilityFeature,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineDispatchSemanticsActionFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        id: u64,
        action: FlutterSemanticsAction,
        data: *const u8,
        data_length: usize,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineOnVsyncFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        baton: isize,
        frame_start_time_nanos: u64,
        frame_target_time_nanos: u64,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineReloadSystemFontsFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEngineTraceEventDurationBeginFnPtr =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
pub type FlutterEngineTraceEventDurationEndFnPtr =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
pub type FlutterEngineTraceEventInstantFnPtr =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char)>;
pub type FlutterEnginePostRenderThreadTaskFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        callback: VoidCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineGetCurrentTimeFnPtr = ::std::option::Option<unsafe extern "C" fn() -> u64>;
pub type FlutterEngineRunTaskFnPtr = ::std::option::Option<
    unsafe extern "C" fn(engine: FlutterEngine, task: *const FlutterTask) -> FlutterEngineResult,
>;
pub type FlutterEngineUpdateLocalesFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        locales: *mut *const FlutterLocale,
        locales_count: usize,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineRunsAOTCompiledDartCodeFnPtr =
    ::std::option::Option<unsafe extern "C" fn() -> bool>;
pub type FlutterEnginePostDartObjectFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        port: FlutterEngineDartPort,
        object: *const FlutterEngineDartObject,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineNotifyLowMemoryWarningFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEnginePostCallbackOnAllNativeThreadsFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        callback: FlutterNativeThreadCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineNotifyDisplayUpdateFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        update_type: FlutterEngineDisplaysUpdateType,
        displays: *const FlutterEngineDisplay,
        display_count: usize,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineScheduleFrameFnPtr =
    ::std::option::Option<unsafe extern "C" fn(engine: FlutterEngine) -> FlutterEngineResult>;
pub type FlutterEngineSetNextFrameCallbackFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        callback: VoidCallback,
        user_data: *mut ::std::os::raw::c_void,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineAddViewFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        info: *const FlutterAddViewInfo,
    ) -> FlutterEngineResult,
>;
pub type FlutterEngineRemoveViewFnPtr = ::std::option::Option<
    unsafe extern "C" fn(
        engine: FlutterEngine,
        info: *const FlutterRemoveViewInfo,
    ) -> FlutterEngineResult,
>;
#[doc = " Function-pointer-based versions of the APIs above."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FlutterEngineProcTable {
    #[doc = " The size of this struct. Must be sizeof(FlutterEngineProcs)."]
    pub struct_size: usize,
    pub CreateAOTData: FlutterEngineCreateAOTDataFnPtr,
    pub CollectAOTData: FlutterEngineCollectAOTDataFnPtr,
    pub Run: FlutterEngineRunFnPtr,
    pub Shutdown: FlutterEngineShutdownFnPtr,
    pub Initialize: FlutterEngineInitializeFnPtr,
    pub Deinitialize: FlutterEngineDeinitializeFnPtr,
    pub RunInitialized: FlutterEngineRunInitializedFnPtr,
    pub SendWindowMetricsEvent: FlutterEngineSendWindowMetricsEventFnPtr,
    pub SendPointerEvent: FlutterEngineSendPointerEventFnPtr,
    pub SendKeyEvent: FlutterEngineSendKeyEventFnPtr,
    pub SendPlatformMessage: FlutterEngineSendPlatformMessageFnPtr,
    pub PlatformMessageCreateResponseHandle: FlutterEnginePlatformMessageCreateResponseHandleFnPtr,
    pub PlatformMessageReleaseResponseHandle:
        FlutterEnginePlatformMessageReleaseResponseHandleFnPtr,
    pub SendPlatformMessageResponse: FlutterEngineSendPlatformMessageResponseFnPtr,
    pub RegisterExternalTexture: FlutterEngineRegisterExternalTextureFnPtr,
    pub UnregisterExternalTexture: FlutterEngineUnregisterExternalTextureFnPtr,
    pub MarkExternalTextureFrameAvailable: FlutterEngineMarkExternalTextureFrameAvailableFnPtr,
    pub UpdateSemanticsEnabled: FlutterEngineUpdateSemanticsEnabledFnPtr,
    pub UpdateAccessibilityFeatures: FlutterEngineUpdateAccessibilityFeaturesFnPtr,
    pub DispatchSemanticsAction: FlutterEngineDispatchSemanticsActionFnPtr,
    pub OnVsync: FlutterEngineOnVsyncFnPtr,
    pub ReloadSystemFonts: FlutterEngineReloadSystemFontsFnPtr,
    pub TraceEventDurationBegin: FlutterEngineTraceEventDurationBeginFnPtr,
    pub TraceEventDurationEnd: FlutterEngineTraceEventDurationEndFnPtr,
    pub TraceEventInstant: FlutterEngineTraceEventInstantFnPtr,
    pub PostRenderThreadTask: FlutterEnginePostRenderThreadTaskFnPtr,
    pub GetCurrentTime: FlutterEngineGetCurrentTimeFnPtr,
    pub RunTask: FlutterEngineRunTaskFnPtr,
    pub UpdateLocales: FlutterEngineUpdateLocalesFnPtr,
    pub RunsAOTCompiledDartCode: FlutterEngineRunsAOTCompiledDartCodeFnPtr,
    pub PostDartObject: FlutterEnginePostDartObjectFnPtr,
    pub NotifyLowMemoryWarning: FlutterEngineNotifyLowMemoryWarningFnPtr,
    pub PostCallbackOnAllNativeThreads: FlutterEnginePostCallbackOnAllNativeThreadsFnPtr,
    pub NotifyDisplayUpdate: FlutterEngineNotifyDisplayUpdateFnPtr,
    pub ScheduleFrame: FlutterEngineScheduleFrameFnPtr,
    pub SetNextFrameCallback: FlutterEngineSetNextFrameCallbackFnPtr,
    pub AddView: FlutterEngineAddViewFnPtr,
    pub RemoveView: FlutterEngineRemoveViewFnPtr,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FlutterEngineProcTable"][::std::mem::size_of::<FlutterEngineProcTable>() - 312usize];
    ["Alignment of FlutterEngineProcTable"]
        [::std::mem::align_of::<FlutterEngineProcTable>() - 8usize];
    ["Offset of field: FlutterEngineProcTable::struct_size"]
        [::std::mem::offset_of!(FlutterEngineProcTable, struct_size) - 0usize];
    ["Offset of field: FlutterEngineProcTable::CreateAOTData"]
        [::std::mem::offset_of!(FlutterEngineProcTable, CreateAOTData) - 8usize];
    ["Offset of field: FlutterEngineProcTable::CollectAOTData"]
        [::std::mem::offset_of!(FlutterEngineProcTable, CollectAOTData) - 16usize];
    ["Offset of field: FlutterEngineProcTable::Run"]
        [::std::mem::offset_of!(FlutterEngineProcTable, Run) - 24usize];
    ["Offset of field: FlutterEngineProcTable::Shutdown"]
        [::std::mem::offset_of!(FlutterEngineProcTable, Shutdown) - 32usize];
    ["Offset of field: FlutterEngineProcTable::Initialize"]
        [::std::mem::offset_of!(FlutterEngineProcTable, Initialize) - 40usize];
    ["Offset of field: FlutterEngineProcTable::Deinitialize"]
        [::std::mem::offset_of!(FlutterEngineProcTable, Deinitialize) - 48usize];
    ["Offset of field: FlutterEngineProcTable::RunInitialized"]
        [::std::mem::offset_of!(FlutterEngineProcTable, RunInitialized) - 56usize];
    ["Offset of field: FlutterEngineProcTable::SendWindowMetricsEvent"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SendWindowMetricsEvent) - 64usize];
    ["Offset of field: FlutterEngineProcTable::SendPointerEvent"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SendPointerEvent) - 72usize];
    ["Offset of field: FlutterEngineProcTable::SendKeyEvent"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SendKeyEvent) - 80usize];
    ["Offset of field: FlutterEngineProcTable::SendPlatformMessage"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SendPlatformMessage) - 88usize];
    ["Offset of field: FlutterEngineProcTable::PlatformMessageCreateResponseHandle"][::std::mem::offset_of!(
        FlutterEngineProcTable,
        PlatformMessageCreateResponseHandle
    ) - 96usize];
    ["Offset of field: FlutterEngineProcTable::PlatformMessageReleaseResponseHandle"][::std::mem::offset_of!(
        FlutterEngineProcTable,
        PlatformMessageReleaseResponseHandle
    ) - 104usize];
    ["Offset of field: FlutterEngineProcTable::SendPlatformMessageResponse"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SendPlatformMessageResponse) - 112usize];
    ["Offset of field: FlutterEngineProcTable::RegisterExternalTexture"]
        [::std::mem::offset_of!(FlutterEngineProcTable, RegisterExternalTexture) - 120usize];
    ["Offset of field: FlutterEngineProcTable::UnregisterExternalTexture"]
        [::std::mem::offset_of!(FlutterEngineProcTable, UnregisterExternalTexture) - 128usize];
    ["Offset of field: FlutterEngineProcTable::MarkExternalTextureFrameAvailable"][::std::mem::offset_of!(
        FlutterEngineProcTable,
        MarkExternalTextureFrameAvailable
    ) - 136usize];
    ["Offset of field: FlutterEngineProcTable::UpdateSemanticsEnabled"]
        [::std::mem::offset_of!(FlutterEngineProcTable, UpdateSemanticsEnabled) - 144usize];
    ["Offset of field: FlutterEngineProcTable::UpdateAccessibilityFeatures"]
        [::std::mem::offset_of!(FlutterEngineProcTable, UpdateAccessibilityFeatures) - 152usize];
    ["Offset of field: FlutterEngineProcTable::DispatchSemanticsAction"]
        [::std::mem::offset_of!(FlutterEngineProcTable, DispatchSemanticsAction) - 160usize];
    ["Offset of field: FlutterEngineProcTable::OnVsync"]
        [::std::mem::offset_of!(FlutterEngineProcTable, OnVsync) - 168usize];
    ["Offset of field: FlutterEngineProcTable::ReloadSystemFonts"]
        [::std::mem::offset_of!(FlutterEngineProcTable, ReloadSystemFonts) - 176usize];
    ["Offset of field: FlutterEngineProcTable::TraceEventDurationBegin"]
        [::std::mem::offset_of!(FlutterEngineProcTable, TraceEventDurationBegin) - 184usize];
    ["Offset of field: FlutterEngineProcTable::TraceEventDurationEnd"]
        [::std::mem::offset_of!(FlutterEngineProcTable, TraceEventDurationEnd) - 192usize];
    ["Offset of field: FlutterEngineProcTable::TraceEventInstant"]
        [::std::mem::offset_of!(FlutterEngineProcTable, TraceEventInstant) - 200usize];
    ["Offset of field: FlutterEngineProcTable::PostRenderThreadTask"]
        [::std::mem::offset_of!(FlutterEngineProcTable, PostRenderThreadTask) - 208usize];
    ["Offset of field: FlutterEngineProcTable::GetCurrentTime"]
        [::std::mem::offset_of!(FlutterEngineProcTable, GetCurrentTime) - 216usize];
    ["Offset of field: FlutterEngineProcTable::RunTask"]
        [::std::mem::offset_of!(FlutterEngineProcTable, RunTask) - 224usize];
    ["Offset of field: FlutterEngineProcTable::UpdateLocales"]
        [::std::mem::offset_of!(FlutterEngineProcTable, UpdateLocales) - 232usize];
    ["Offset of field: FlutterEngineProcTable::RunsAOTCompiledDartCode"]
        [::std::mem::offset_of!(FlutterEngineProcTable, RunsAOTCompiledDartCode) - 240usize];
    ["Offset of field: FlutterEngineProcTable::PostDartObject"]
        [::std::mem::offset_of!(FlutterEngineProcTable, PostDartObject) - 248usize];
    ["Offset of field: FlutterEngineProcTable::NotifyLowMemoryWarning"]
        [::std::mem::offset_of!(FlutterEngineProcTable, NotifyLowMemoryWarning) - 256usize];
    ["Offset of field: FlutterEngineProcTable::PostCallbackOnAllNativeThreads"]
        [::std::mem::offset_of!(FlutterEngineProcTable, PostCallbackOnAllNativeThreads) - 264usize];
    ["Offset of field: FlutterEngineProcTable::NotifyDisplayUpdate"]
        [::std::mem::offset_of!(FlutterEngineProcTable, NotifyDisplayUpdate) - 272usize];
    ["Offset of field: FlutterEngineProcTable::ScheduleFrame"]
        [::std::mem::offset_of!(FlutterEngineProcTable, ScheduleFrame) - 280usize];
    ["Offset of field: FlutterEngineProcTable::SetNextFrameCallback"]
        [::std::mem::offset_of!(FlutterEngineProcTable, SetNextFrameCallback) - 288usize];
    ["Offset of field: FlutterEngineProcTable::AddView"]
        [::std::mem::offset_of!(FlutterEngineProcTable, AddView) - 296usize];
    ["Offset of field: FlutterEngineProcTable::RemoveView"]
        [::std::mem::offset_of!(FlutterEngineProcTable, RemoveView) - 304usize];
};
unsafe extern "C" {
    #[doc = " @brief      Gets the table of engine function pointers.\n\n @param[out] table   The table to fill with pointers. This should be\n                     zero-initialized, except for struct_size.\n\n @return     Returns whether the table was successfully populated.\n"]
    pub fn FlutterEngineGetProcAddresses(table: *mut FlutterEngineProcTable)
        -> FlutterEngineResult;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
